# 大表优化

当单表记录过大时，性能会下降，应该进行优化。

1. 查询时候限定数据范围。比如查用户的历史订单可以控制在一个月的范围内

## 读/写分离

数据库拆分，主库负责写，从库负责读。

## 垂直分区

根据数据库里数据表的相关性进行拆分。比如用户表中既有用户的登录信息，又有基本信息，分成两个单独的表。
把一个列比较多的表拆分成多个表。

优点： 可以是列数据变小，查询时候煎炒读取的块数。简化表结构，容易维护
缺点： 主键冗余，引起Join操作。会使事务变得复杂

## 水平分区
保持数据表结构不变，通过某种策略存储数据分片。每一片数据分散在不同表或者库中，达到了分布式的目的。可以支撑非常大的数据。如果表还在一个机器上，对于提升mysql的并发能力没意义，水平最好分库。

缺点： 分片事务难以解决，跨节点Join性能差，逻辑复杂。尽量不要进行分片。

分片方案：
   * 客户端代理：分片逻辑在应用端，封装在Jar包里，通过修改和封装数据层实现。 
   * 中间件代理：在应用和数据中间加一个代理层，分片逻辑同一维护在中间服务中。

分片之后的id如何处理：
  1. uuid: 不合适
  2. 自增Id, 无法实现
  3. redis, 可以实现，但是复杂。
  4. 美团的Leaf  利用号段，双缓冲区来获取ID


# 视图
视图就是一个虚拟的表，其数据实际上是来源于真实的表。
因此，对视图的删改查实际上是对形成视图的真实的表的删改查。

```sql
mysql>CREATE VIEW oceania AS 
SELECT * FROM country WHERE continent = 'Oceania'
WITH CHECK OPTION;
```

其中，`WITH CHECK OPTION`语句是限制使用视图更新时，更新的东西必须是视图条件内的行。比如要去更新一个continent != ‘Oceania’的数据是不行的，只能更新等于Oceania的数据

#### 视图的限制

- 不能对视图创建触发器
- 使用临时表算法实现的视图，无法被更新
- 无法使用SHOW CREATE VIEW来查看视图定义语句

# 外键
Innodb强制外键使用索引。外键有成本，每次修改数据都要在另一张表中执行一次查找。
**如果想确保两个相关表始终有一致的数据,那么使用外键比在应用程序中检查一致性的性能要高得多**

有时,可以使用触发器来代替外键。对于相关数据的同时更新，那么外键更合适,但是如果外键只是用作数值约束,那么触发器或者显式地限制取值会更好些。(这里,可以直接使用ENUM类型。)

如果只是使用外键做约束,那通常在应用程序里实现该约束会更好。外键会带来很大的额外消耗。

# 在mysql内存存储代码
触发器、存储过程、函数
## 存储过程
创建一个简单的存储过程的例子，用来写入一定数量的数据到一个表中：

```sql
mysql>DROP PROCEDURE IF EXISTS insert_many_rows;

delimiter //

CREATE PROCEDURE insert_many_rows (IN loops INT)
BEGIN
	DECLARE v1 INT; -- IN、OUT、INOUT。IN是调用者传入的参数，但是传入后该参数的改变调用者无法“看到”。INOUT也是调用者传入的参数并且可以指定初始化值，但是该参数的改变调用者是可以“看到”的。OUT是一个初始化值为NULL的参数，不管你调用的时候给它设置什么值都没用，你只能传一个变量来得到最终输出的参数。
	SET v1=loops;
	WHILE v1 > 0 DO -- 不要忘了 DO 这个关键字
		INSERT INTO test_table values(NULL, 0,'hahah');
		SET v1 = v1 - 1;
	END WHILE;
END;
//
delimiter ;
```

## 触发器

触发器就是在增删改的时候，可以自动地执行一段逻辑代码。还可以指定是增删改之前触发还是之后。

触发器有一些特别需要注意的地方：

* 针对每个表的每一个事件，只能有一个触发器。
* MySQL 只支持""基于行的触发"——也就是说，触发器始终是针对一条记录的，而不是针对整个 SQL 语句的。如果变更数据集很大，效率会很低。

下面这些触发器本身的限制也适用于 MySQL：

- 触发器可以掩盖服务器背后的工作，一个简单的 SQL 语句背后，因为触发器，可能包含了很多看不见的工作。

- 激活触发器的语句也会失败，这会导致难于分析和定位，不知道是原语句的问题还是触发器的问题。

- 触发器可能导致死锁和锁等待。如果触发器失败，那么原来的 SQL 语句也会失败。如果没有意识到这其中是触发器在搞鬼，那么很难理解服务器抛出的错误代码是什么意思。

## 事件
事件有点类似于 Linux 的定时任务，不过是完全在 MySQL 内部实现的。通常，我们会把复杂的 SQL 都封装到一个存储过程中，这样事件在执行的时候只需要做一个简单的CALL 调用。

## 函数

自定义函数， 比如cte 

# 字符集和校对
主要问题在于，Mysql有一堆和字符集有关的设置，然而，用户常常搞不清楚到底哪个设置生效…………

Mysql的字符集设置是逐层嵌套的，整个服务器有字符集的设置，表有字符集的设置，表中的某列也有字符集的设置。这些设置都是从下而上逐层覆盖的，先看列的设置，列没设置就算表的设置，表也没设置那就认整个服务器的设置。

下面是一些常用设置的介绍：

- character_set_client：服务器端收到客户端的字符时，总是假设客户端的字符是这个设置配置的字符集

- character_set_connection：一旦收到了客户端的字符，服务器端会先将字符转换成这个设置所配置的字符集，即会从character_set_client的字符集转换为character_set_connection的字符集

- character_set_result：服务器端返回数据时，总是将数据的字符由character_set_connection的字符集转换为character_set_result的字符集

- character_set_server：整个服务器字符集的默认设置

- character_set_database：默认数据库的字符集的设置，当没有使用`use database`命令来指定要使用的数据库时，这个值和character_set_server是一样的。如果你切换了正在使用的数据库，这个值会跟着改变

- character_set_filesystem：指定当使用`LOAD DATA INFILE`和`SELECT...INTO OUTFILE`语法的时候，文件的文件名使用的字符集。

- character_set_system：服务器存储标识符的时候使用的字符集，总是utf-8，应当是不可动态修改的吧

- character_sets_dir：指定字符集设置存放的路径，也是不可动态修改的值


# 查询缓存
在前几章已有提及，MySQL在服务器的入口处有个命中查询缓存的过程，一旦命中，立刻返回之前缓存的查询结果，而无需执行解析、优化、查询这些阶段。

查询缓存系统会跟踪查询中涉及的每个表，如果这些表发生变化，那么和这个表相关的所有的缓存数据都将失效。这种机制效率比较低，但这种简单实现代价很小，而后者对非常繁忙的系统来说还是很重要的。

随着现在的通用服务器越来越强大，查询缓存被发现是一个影响服务器扩展性的因素。因此作者的意见是应该默认关闭查询缓存，如果缓存的作用很大的话，建议设置一个较小的缓存空间，比如几十兆。

**MySQL是如何判断缓存命中的？有如下要点：**

* MySQL是通过哈希查找来判断缓存命中的，将查询语句，查询涉及的数据库、客户端协议版本等影响返回结果的信息变成哈希值和返回结果存储在一张引用表里。这意味着，查询语句中的任何字符的改变，甚至多一个空格，注释，都有可能影响命中。

* 当查询语句中有不确定的数据时，查询结果根本不会缓存，比如now()这样的函数，由于查询结果不会缓存，那么缓存也就不会命中了。另外，查询中包含自定义函数、存储函数、用户变量、临时表、系统表等等都不会被缓存。(MySQL 在任何时候只要发现不能被缓存的部分，就会禁止这个查询被缓存。)

**查询缓存可能会带来的额外消耗**

* 打开查询缓存意味着所有的查询语句涉及读操作的，都要先检查是否命中缓存。
* 所有读操作结束返回结果的时候，如果结果可以被缓存，需要将结果存入缓存。
* 写操作结束时，需要将查询缓存中因为写操作而失效的缓存都消除。
* 如果在一个事务中修改了某个表，由于要保证事务的隔离性，会限制这个表对应的查询缓存，在这个事务结束之前，任何外部事务包括这个事务，都无法使用跟这个表有关的缓存，也无法对涉及这个表的查询进行缓存。因此，长时间运行的事务会降低缓存命中率。
* 缓存在失效的时候，消除失效缓存的操作由一个全局锁保护，导致所有检查缓存命中和检查缓存失效的查询都要等待，这个时候系统可能会僵死一会儿。这就是为什么书中不推荐使用查询缓存或者推荐设置很小的缓存空间的原因。

**查询缓存相关设置**

query_cache_type：查询缓存的开关，有ON、OFF、DEMAND三个可选值，其中DEMAND的意思是，只有用户在查询语句中用SQL_CACHE指明才使用查询缓存。
query_cache_size：缓存使用的总空间，必须是1024的整数倍，单位为字节。
query_cache_min_res_unit：查询缓存分配内存时的最小单位
query_cache_limit：能够缓存的最大结果。如果查询结果大于这个值，不会缓存。如果预先知道会有这种情况，最好查询语句里直接指定SQL_NO_CACHE。
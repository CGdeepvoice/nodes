# Mysql 架构和历史
## 并发控制
1. 在处理并发读写时，可以通过实现一个由两种行级锁组成饿锁系统来解决问题。两种锁(常见)：
    - 共享锁 又称读锁，多个客户在同一时刻可以同时读取同一个资源，互不干扰。
    - 排它锁 又称写锁，一个写锁会阻塞其他的写锁和读锁。(记录锁、间隙锁、临键锁都属于排它锁)
    当事务T1在r行持有一个共享锁时，此时如果T2想对r行上锁要遵守以下步骤：
      * 如果T2申请的是共享锁，可以立即获取。
      * 如果T2申请的是排他锁，会阻塞，等待T1释放


2. 这里需要注意，普通的select没有任何锁机制。 因为是MVCC


3. Intention Locks 意向锁， 意向锁时表级锁
    InnoDB支持多种粒度的锁并存，为了让这种并存方式更加切实可行的，使用了意向锁。意向锁是表级锁，只是事务稍后对表中的航需要那中类型的锁。这里有两种：
    * intention shared lock（IS） 意向共享锁，表示事务打算在表中的行上设置共享锁。 `select ... for share`
    * intention exclusive lock(IX) 意向排它锁，表示事务在表中的行上设置排它锁。 `select ... for update`
    
    示例(https://www.zhihu.com/question/51513268/answer/127777478)：
    ```text
    事务A锁住了表中的一行，让这一行只能读，不能写。
    之后，事务B申请整个表的写锁。如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。
    数据库需要避免这种冲突，就是说要让B的申请被阻塞，直到A释放了行锁。
    数据库要怎么判断这个冲突呢？
    step1：判断表是否已被其他事务用表锁锁表
    step2：判断表中的每一行是否已被行锁锁住。
    注意step2，这样的判断方法效率实在不高，因为需要遍历整个表。
    于是就有了意向锁。在意向锁存在的情况下，事务A必须先申请表的意向共享锁，成功后再申请一行的行锁。在意向锁存在的情况下，上面的判断可以改成step1：不变step2：发现表上有意向共享锁，说明表中有些行被共享行锁锁住了，因此，事务B申请表的写锁会被阻塞。
    注意：申请意向锁的动作是数据库完成的，就是说，事务A申请一行的行锁的时候，数据库会自动先开始申请表的意向锁，不需要我们程序员使用代码来申请。
    ``` 

4. 记录锁： Record Locks AKA行锁 封锁记录，防止其他事务插入、更新或者删除：`select * from test wher id = 1 for update;

5. 间隙锁： Gap Locks:
    间隙锁是封锁索引记录中的间隔，或者第一条索引记录之前的范围，又或者最后一条索引记录之后的范围。
    产生间隙锁的条件（RR隔离级别下）：
    1. 使用普通索引锁定
    2. 使用多列唯一索引
    3. 使用唯一索引锁定多行记录：
    以上情况都会产生间隙锁。

    唯一索引的间隙锁：
      1. 对于制定查询某一条记录的加锁语句，**如果该记录不存在，就会产生记录锁和间隙锁，如果记录存在，只会产生记录锁**，如： `where id = 5 for update`
      2. 对于查找某一范围内的查询语句，会产生间隙，如：`where id between 5 and 7 for update`
    普通索引的间隙锁：
      1. 在普通索引列上，**无论何种查询，只要加锁都会产生间隙锁，这和唯一索引不一样**；
      2. 在普通索引跟唯一索引中，数据间隙的分析，数据行是优先根据普通索引排序，再根据唯一索引排序。

6. 临键锁 next-key locks
    临键锁时记录锁和间隙锁的组合，他的封锁范围既包含索引记录，又包含索引区间。
    临键锁是为了避免幻读。如果事务级别降级为RC，临键锁也会失效。

7. 锁粒度：
    - 表锁(table lock)，是Mysql中最基本的策略，开销最小。原理是锁定整张表，一个用户在对其进行写操作（insert,delete, update)前，需要先获取锁，这个锁会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的客户才能获得读锁，读锁之间是不阻塞的。写锁的优先级高于读锁，一个写锁请求可能会被插入到读锁队列的前面。
    - 行级锁(row lock), 可以最大程度的只吃并发处理，开销最大。行级锁只在存储引擎层实现，mysql服务器没有实现。
## 事务
一组原子性的sql查询，独立的工作单元。如果数据库引擎能够成功的对数据库应用该组查询的全部语句，就执行该查询。如果其中任何一条语句无法执行，所有的都不执行。事务内的语句，要么全部执行成功，要么全部执行失败。
1. 示例：假设银行数据库有两张表，支票表（checking)和储蓄表(savings)，现在从用户Jane的支票账户转移200美元到她的储蓄账户，需要三个步骤：
   * 检查支票账户的余额高于200美元
   * 从支票账户余额减去200美元
   * 在储蓄账户余额中增加200美元
2. 上述的三个步骤必须是打包在一个事务中的，任何一个步骤失败，则必须回滚所有的步骤。
```sql
START TRANSACTION
SELECT blance FROM checking WHERE customer_id = 123;
UPDATE checking SET blance = blance - 200.00 WHERE customer_id = 123;
UPDATE savings SET blance = blance + 200.00 WHERE customer_id = 123;
COMMIT;
```
3. **ACID**:
   * A atomicity 原子性
       一个事务必须视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作。
   * C consistency 一致性
       数据库总是从一个一致性状态转换到另一个一致性转态。在前面的例子中，一致性确保了即使在Update语句执行时候失败，支票账户也不会损失200美元，因为事务最终没有提交，所以事务中的修改也不会保存到数据库中。
   * I isolation 隔离性
       通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。在前面的例子中，当时行完第三条语句时、第四条语句没开始时，此时另外一个账户汇总程序开始执行，则其看到的支票账户的余额并没有被减去200美元，后面讲隔离级别的时候，会发现为什么说通常是不可见的。
   * D durability 持久性
       一旦事务提交，则其所做的修改就会永久保存到数据库。（此时即使系统崩溃，修改的数据也不会丢失。持久性是个有点模糊的概念，因为实际上持久性也分很多不同的级别。有些持久性策略能够提供非常强的安全保障，而有些则未必，而且不可能有能做到100%的持久性保证的策略。）
4. 隔离级别
   1. sql标准汇总定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，在哪些事务内和事务间是可见的，那些不可见。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。
   2. 四种隔离级别：
        * READ UNCOMMITTED(未提交读)
            在READ UNCOMMITTED级别，事务中的修改，即使没有提交，对其他事务也是可见的。事务中可以读取未提交的数据，称为脏读(Ditry Read)。这个级别会导致很多问题，从性能上说，READ UNCOMMITTED不会比其他级别好太多，但是缺乏了其他级别的好处，实际应用很少使用。
        * READ COMMITTED(提交读)
            READ COMMITTED满足前面提到的隔离性的简单定义：一个事务开始时，只能看见已经提交的事务所做的修改。换句话说，一个事务从开始知道提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重复度（nonrepeatable read)，因为两次执行相同的查询，可能得到不一样的结果。
            [连接](https://www.bilibili.com/video/av56213994)
        * REPEATABLE READ(可重复读)
            REPEATABLE READ解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。在理论上，可重复读隔离界别还是无法解决另一个幻读(Phantom Read)的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行(Phantom Row)。可重复读是Mysql默认的事务隔离级别。
        * SERIALIZABLE(可串行化)
            SERIALIZABLE是最高的隔离级别。通过强制事务串行执行，避免了前面所说的幻读的问题。简单的说，SERIALIZABLE会在读取的每一行数据上加锁，所以可能导致大量的超时和锁争用的问题。实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。
        
        名称|级别|脏读|不可重复读|幻读|加锁读
        :-:|:-:|:-:|:-:|:-:|:-:
        读未提交|read uncommitted|是|是|是|no
        读已提交|read committed|否|是|是|no
        可重复读|repeatable read|否|否|是|no
        串行化|serializable|否|否|否|yes
    3. 出现的问题：
        * 不可重复读：一个事务中两次读取的数据内容不一致，要求的是一个事务中多次读取数据是一致的，这是事务Update时引发的问题
        * 幻读：幻读侧重的方面是某一次的select操作得到的结果所表示的数据状态无法支撑后续的业务操作。 一个事务对一个表中的数据进行了修改，比如获取全部行，同时第二个事务也修改了表中的数据，这种修改是向表中插入新数据。以后就会发生操作第一个事务的用户发现表中有没有修改的数据行，好像发生了幻觉一样。 select某个记录不存在，则进行插入此记录，但执行insert时发现此记录已经存在无法插入。
        **其实不可重复读重点在于update和delete，而幻读的重点在于insert**

5. 死锁
   两个或者更多事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的循序锁定资源时，就可能会产生死锁。多个事务同时锁定同一个资源时候，也会产生死锁。
   StockPrice表：

   事务1：
   ```sql
   START TRANSACTION
   UPDATE StockPrice SET close = 45.50 WHERE stock_id = 4 and date = '2002-05-01';
   UPDATE StockPrice SET close = 19.80 WHERE stock_id = 3 and date = '2002-05-02';
   COMMIT;
   ```

   事务2：
   ```sql
   START TRANSACTION
   UPDATE StockPrice SET high = 20.12 WHERE stock_id = 3 and date = '2002-05-02';
   UPDATE StockPrice SET high = 47.20 WHERE stock_id = 4 and date = '2002-05-01';
   COMMIT;
   ```
   如果凑巧，两个事务都执行了第一条UPDATE语句，更新了一行数据，同时也锁定了改行数据，接着每个事务都尝试去执行第二条update语句，却发现改行已经被对方锁定，然后两个事务都等待对方释放锁，同时又持有对方需要的锁，则陷入死循环。除非有外部因素介入才能解除死锁。

   为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，比如InnoDB存储引擎，越能检测到死锁的循环依赖，并立即返回一个错误。这种解决方式很有效，否则死锁会导致出现非常慢的查询。还有一种解决方式，就是当查询的时间达到锁等待超时的设定后放弃锁请求，这种范式通常来说不太好。InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚（这是相对比较简单的死锁回滚算法）。

   锁的行为和顺序是和存储引擎有关的。以同样的循序执行语句，有些存储引擎会产生死锁，有些则不会。死锁的产生有双重原因：有些事因为真正的数据冲突，这种情况通常很难避免，但有些则完全由于存储引擎的实现方式导致的。
6. 事务日志：
    事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘内的多个地方移动磁头（机械硬盘），所以采用事务日志的方式相对来说要快得多。事务日志持久以后，内存中别修改的数据在后台可以慢慢的刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志（Write-Ahead Logging),修改数据需要写两次磁盘。

    如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘。此时系统崩溃，存储引擎在重启时能够自动回复这部分修改的记录。

7. MYSQL中的事务。
   1. 自动提交（AUTOCOMMIT) MYSQL默认的是自动提交模式。也就是说如果不是显示的开始一个事务，则每个查询都被当做一个事务执行提交操作。可以通过设置 AUTOCOMMIT 变量来控制自动提交模式（1或者ON表示启用，0或者OFF表示禁用）。
   2. MySQL 可以通过执行 `SET TRANSACTION ISOLATION LEVEL + 隔离级别` 命令来设置隔离级别。新的隔离级别会在下一个事务开始的时候生效。可以在配置文件中设置整个数据库的隔离级别，也可以只改变当前会话的隔离级别。
   3. 隐式和显式锁定

    InnoDB 采用的是两阶段锁定协议。在事务执行过程中,随时都可以执行锁定,锁只有在执行commit和rollback的时才会被释放,并且所有的锁是同一时刻被释放，前面描述的都是隐式锁定,InnoDB会根据隔离级别在需要的时候自动加锁。

    另外,InnoDB也支持通过特定的语句进行显示锁定,这些语句不属于sql规范(尽量避免使用)：

    ```sql
    SELECT ... LOCK IN SHARE MODE

    SELECT ... FOR UPDATE
    ```
## 多版本并发控制
1. 可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。
2. 实现： 保存通过数据在某个时间点的快照来实现。也就是说，不管需要 执行多长时间每个事务看得到的数据都是一致的。根据事务开始的事件不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。
3. InnoDB存储引擎MVCC的实现策略：
    
    ​   在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号（可能为空）。这里的版本号并不是实际的时间值，而是系统版本号。**每开始一个新的事务，系统版本号都会自动递增。**事务开始时刻的系统版本号会作为事务的版本号，用来和查询每行记录的版本号进行比较。
4. MVCC具体的操作
   **SELECT**

​	InnoDB会根据以下两个条件检查每行记录：

   * InnoDB 只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，只么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
   * 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。

   只有1和2同时满足的记录，才能做为查询结果。

   **INSERT**

   ​	InnoDB 为新插入的每一行保存当前系统版本号作为行版本号。

   **DELETE**

   ​	InnoDB为删除的每一行保存当前系统版本号作为行删除标识。

   **UPDATE**

   ​	InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统的版本号到原来的行作为行删除标识。

   
    保存这两个额外系统版本号，使大多数操作都可以不用加锁。这样设计使得计数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。

    MVCC 只在 `REPEATABLE READ`和`READ COMMITED`两个隔离级别下工作，其它两个隔离级别和MVCC不兼容。因为 `READ UNCOMMITTED`总是读取最新的数据行，而不是符合当前事务版本的数据行。而`SERIALIZABLE` 则会对所有读取的行都加锁。



## 乐观锁和悲观锁
1. 为了实现并发控制的手段，大致可以分为乐观并发控制和悲观并发控制。
2. 悲观锁：
    
    在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）。
    1. 主要实现是共享锁和排它锁。
    2. 策略： 先取锁再访问。
    3. 但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会。另外还会降低并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。
    4. 实现方式：
       1. 在对记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。
       2. 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。
       3. 如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。
       4. 期间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。


3. 乐观锁 Optimistic Locking：
   乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。
   **实现方式：**
   1. 使用乐观锁就不需要借助数据库的锁机制了。

   2. 乐观锁的概念中其实已经阐述了它的具体实现细节。主要就是两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是CAS(Compare and Swap)。CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。


## 总结
1. 两段锁: 僵尸舞分为两个阶段，加锁阶段和解锁阶段：
   * 加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁（共享锁，其它事务可以继续加共享锁，但不能加排它锁），在进行写操作之前要申请并获得X锁（排它锁，其它事务不能再获得任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。
   * 解锁阶段：当事务释放了一个封锁后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。

    事务|加锁/解锁处理
    -:|:-
    begin|
    insert into test... | 加insert对应的锁
    update test set ... | 加update对应的锁
    delete from test...| 加delete对应的锁
    commit; | 事务提交时，同时释放insert,update,delete对应的锁

2. 对于可重复读RR，sql标准规定中，可以存在幻读现象，可以通过表锁来解锁，也就是可串行化，但是InnoDB通过自己的方式来解决这个问题。
3. 首先要搞清楚，这里的读有两种：
    * 快照读： 简单的select，不加锁，但是会通过MVCC来控制。
    * 当前读： 特殊的读操作，插入/更新/删除操作，输入当前读，要加锁。
    ```sql
    select * from table where ? lock in share mode; （加S锁） 
    select * from table where ? for update;（加X锁） 
    insert into table values (…);（加X锁） 
    update table set ? where ?;（加X锁） 
    delete from table where ?;（加X锁）
    ```
4. RR级别通过这两种读来解决了幻读的现象
5. 关于MVCC和乐观锁，这里有些纠结，不知道是不是一个东西，后面查资料也没查出来，美团的以文章了里总结了 MVCC是乐观锁的一种实现，而当前读其实就是一种悲观锁。
[美团技术沙龙-InnoDB](https://tech.meituan.com/2014/08/20/innodb-lock.html)

## TODO
1. GAP-lock 涉及了聚簇索引，写到后面需要回来补
## 基础
1. 数据类型

String
格式 set key value

Hash
格式 hmset name key1 value1 key2 value2

List
格式 lpush name value
     rpush name value
     lrem name index
     llen name 查看长度

Set
    sadd name value

zset 有序集合
    zadd name score value

2. 持久化

两种方式RDB AOF。
RDB就是快照，通过保存和读取文件来实现持久化，在一定的时间将数据保存到硬盘上

AOF是是追加日志的方式，保存每个命令
存储结构： redis通信协议（RESP）格式的文件命令文本存储。
RESP协议：客户端发送命令的格式，5种类型
- 简单字符串 以"+"开头
- 错误 以"-"开头
- 整数 以":"开头
- 大字符串类型 以"$"开头
- 数组 以"*"开头

3. 架构模式
    1.  单机模式 内存容量有限，无法高可用
   
    2. 主从复制 
       一个主几点，多个从节点，从节点就是主节点的复制，可以作为备份，或者从节点只读减轻压力。如何保证消息时同步的？
       1. 增量同步，主节点会将自己存储的操作指令发给每个从节点。从节点接收到之后会进行同步数据。
       2. 快照同步。 主节点会fork一个子进程对主节点做一次内存快照备份发给从节点。从节点接收后会加载快照。
    3. 哨兵模式 
       哨兵会不断检查主服务器和从服务器是否正常，当某个服务器出问题，哨兵会向管理员通知。当主服务器不能正常运行，哨兵会自动故障迁移操作，会在从节点中选出一个节点作为主节点，客户端访问以前的主节点地址会失败，哨兵返回新的地址。以前的主节点恢复之后作为从节点加入进来。
    4. 集群 代理型
        有多个主节点，每个主节点有多个从节点，多个哨兵进行守卫。客户端访问时先访问代理，代理选择主节点进行应答。通过数据冗余来增强可用性。
    5. 集群 直连型
        无中心架构，不需要代理。数据按照slot存储在多个节点，节点直接数据共享。


4. 他的底层也是一个hashtable, 数组和链表组成的。一直保持在内存中，单线程运行

为什么用单线程：
 - 大部分请求都是内存操作
 - 单线程可以避免上下文切换
 - 使用epoll进行io复用。


5. 缓存

缓存穿透：key对应的数据再数据库中不存在，每次针对此key的请求再缓存中都找不到，会请求数据库，这样会压垮数据库。黑客可能会利用这个漏洞来攻击。
解决方案：
 - 布隆过滤器。 将所有可能存在的数据哈希保存到一个足够大的bitmap中，一个一定不存再的key会直接被这个bitmap拦截下来。
 - 就算查询是空的，也将结果进行缓存，但是过期时间很短。

缓存击穿：key对应的数据存在，但是过期了，此时有大量并发请求过来，这些请求发现缓存过期了会从数据库查询并设置回缓存。这时候可能回压垮db.
解决方案：使用锁机制，setnx，就算查数据库，相同的查询只要一个就行了，获取不到锁的就等着查缓存。

缓存雪崩：当缓存服务器重启或大量缓存集中再一个时间段失效。这样也会带来很大压力。
解决方案：
  - 设置缓存过期时间是一个随机值，不要设置成一样的，就不会同一时间失效。
  - 或者设置二级缓存，第二季过期时间比较久。
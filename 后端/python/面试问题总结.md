1. 生成器和迭代器

生成器generator，可以解决数据量过大，内存无法保存的情况。可以使用yield，每次for循环，或者next时才会继续计算，并返回
```python
def fib(times):
    a = 0
    b = 1
    n = 1
    while n <= times:
        yield b
        a, b = b, a+b
        n += 1

x = fib(10)
# for n in x:
#     print(x)
while True:
    print(next(x))
```
生成器就是每次调用都生成一个数据

迭代器就是一个可迭代对象，例如list, string.可以在自定义的类中加入 `__iter__`,`__getitem__`, `next`等方法
区别
```python
# __getitem__()
class DataTest():
    def __init__(self, num):
        self.num = num
    
    def __getitem__(self, index):
        if (index < self.num):
            return index
        else:
            raise StopIteration

data = DataTest(20)
for i in data:
    print(i) # 0, 1, 2, ... 19, index是一个自增的变量

print(data[0]) # 直接传递index
```
```python
# __iter__, __next__
class Fib:
    def __init__(self):
        self.a = 0
        self.b = 1
    def __iter__(self):
        return self
    
    def __next__(self):
        self.a, self.b = self.b, self.a+self.b
        return self.a

f= Fib()
for i in f:
    if i > 100:
        break
    print(i)
```
2. 函数前面加下划线

加单下划线是受保护的。双下滑线表示私有的。但是可以通过类名来访问 
```python
class Foo:
    def __name():
        return '1'

f = Foo()
f.__name() # 这样会报错，可以通过f_Foo__name()来访问
```

3. 三元表达式
python中没有`>?:`，用if-else来模拟

```python
a = 1
b = a if a ==1 else 2
```
4. 深浅拷贝

```python
copy, deepcopy

a = {1: [1,2, 3]}
b = a.copy()
a[1].append(4)
# a = {1: [1, 2, 3, 4]}, b = {1: [1, 2, 3, 4]}
from copy import deepcopy
c = {1: [1,2, 3]}
d= deepcopy(c)
c[1].append(4)
# c = {1: [1, 2, 3, 4]}, d = {1: [1, 2, 3]}
```
浅拷贝会拷贝引用，深拷贝对所有内容复制

5. 多个装饰器

多个装饰器装饰的顺序是从里到外，调用的顺序是从外到里
```python
def f1(fn):
    print("f1")
    def inner(*arg, **kwargs):
        print("进入f1")
        result= fn(*arg,**kwargs)
        print("进入f1里面")
        return result
    return inner

def f2(fn):
    print("f2")
    def inner(*arg, **kwargs):
        print("进入f2")
        result = fn(*arg, **kwargs)
        print("进入f2里面")
        return result
    return inner
@f1
@f2
def fn():
    print("1")
    return "结束"

fn()
# f2
# f1
# 进入f1
# 进入f2
# 1
# 进入f2里面
# 进入f1里面
```

6. django orm

    only 只取出表中的某几列，defer表示不取出某几列

    selected_related 相同于进行join,解决1对1或者多对1的关系。
    prefetch_related 对于多对多的关系。分别查表，然后用Python 处理他们的关系

7. Django 中间件

    process_request，从下到上，process_response从上到下。
    自定义中间件，继承MiddlewareMixin, 重写process_request, 和process_response
    可以用来记录日志

8. drf常见组件，permission_classes, autuentication_classes, filter ,自定义组件继承自对应的已定义的组件，并添加对应的选项。

例如 自定义serializer,继承自ModelSerializer, 写下要序列化的字段。Meta字段定义model
drf优点：
  - 前后端分离
  - 提高REST API效率

序列化： 将模型对象转换为json字典的过程
反序列化： 将客户端传递过来的数据转化为模型对象的过程。

9. restful api：

发送批量删除请求， `POST /XX/delete/` body里放入ID列表

10. 可变对象与不可变对象

不可变对象：int, str, 元组。声明定义时候会申请一块内存，并赋值，不能进行修改，对指针引用的修改，也就是对变量重新赋值，重新申请内存。
可变对象：set,list,dict

11. is 和 ==

is 判断引用是否相同，也就是对应的id值相同。指针指向同一内存地址。
== 比较两个对象的内容相同，默认调用`__eq__()`方法

12. 垃圾回收

默认的垃圾回收机制是使用引用计数，每个对象中使用一个变量来保存引用计数，当计数为0的时候可以清理。
但是垃圾回收会有循环引用的问题。
```python
a = {} # 计数为1
b = {} # 计数为1
a["b"] = b # 计数为2
b["a"] = a # 计数为2
del a # 计数为1
del b # 计数为1
```
del操作之后，计数为1则无法进行清理操作。这里需要使用标记清除算法，使用可达性分析来标记出需要清理的对象，之后进行删除。可达性分析是以栈变量，全局变量，寄存器为根，向下寻找引用，如果某些对象是不可达的，就是应该进行清理的。
可以使用分代算法，利用空间换时间来加速垃圾清理的过程。分为新生代，中年代和老年代。

13. 多重继承

可以向接口一样使用，比如定义父类 Runnable, Flyable, 定义mixin类，来表示可以实现什么方法。通过普通继承表示是什么。
如果继承的两个类中有相同的函数，则调用顺序是按照定义的顺序。


14. django permission()

```
has_permission(self, request, view)
has_object_permission(self, request, view, obj)
```
第一个表示对接口有权限，第二个表示对查询的结果有权限

15. django中的F和Q

F是用来比较同一个model的不同字段。
```python
Book.objects.filter(id__gt=F("price")) # 查询id值大于价格的书籍
Book.objects.all().update(price=F("price")+30)
```
Q查询主要用作and,or,not
```python
# and
Question.objects.filter(Q(question_text__contains="you"), Q(question_text_contains="what"))
# or
Question.objects.filter(Q(question_text__contains="you") | Q(question_text_contains="what"))
# not
Question.objects.filter(~Q(question_text__contains='you'))
```
16. 正则表达式
    
re.match(pattern, line, flag)
表示从头开始匹配，返回的结果在group()中，使用group(1)进行读取

re.search(pattern, line, flag)
扫描整个字符串并返回第一个成功的匹配

re.sub(pattern, repl, line, flag)
将line中匹配成功的部分替换为repl

re.compile(pattern, flag)
用来编译正则表达式，生成一个结果供match,search使用

re.findall(pattern, line)
表示查找所有，返回列表

re.finditer(pattern, line)与上面一样，不过返回一个迭代器

re.split()表示可以将字符串分割返回列表

标志位flag:
  1. re.I 大小写不敏感
  2. re.M 多行匹配
  3. re.S .可以匹配符号

正则表达式模式：
  1. `^` 开头
  2. `$` 结尾
  3. `.` 匹配任意字符，除了换行符.可以使用re.DOTALL,表示匹配包括换行符在内的任意字符
  4. `[...]` 表示一组字符， 如`[abc]` 可以匹配a,b,c任意一个
  5. `[^...]` 表示不在列表中的字符
  6. `*` 0个或者多个
  7. `+` 1个或者多个
  8. `?` 匹配前面0个或者1个前面正则表达式定义的片段，非贪婪模式
  9. `{n}` 具体有几个前面重复的
  10. `{n,}` 至少n个。 n,0 和 * 等价， n,1和+等价
  11. `{n, m}` n到m次
  12. `a|b` a或者b
  13. `()` 对匹配的内容分组，并记住匹配的文本
  14. `\w` 匹配字母数字和下划线
  15. `\W` 非字母数字和下划线
  16. `\s` 空白字符
  17. `\S` 非空字符
  18. 
1. 生成器和迭代器

生成器generator，可以解决数据量过大，内存无法保存的情况。可以使用yield，每次for循环，或者next时才会继续计算，并返回
```python
def fib(times):
    a = 0
    b = 1
    n = 1
    while n <= times:
        yield b
        a, b = b, a+b
        n += 1

x = fib(10)
# for n in x:
#     print(x)
while True:
    print(next(x))
```
生成器就是每次调用都生成一个数据

迭代器就是一个可迭代对象，例如list, string.可以在自定义的类中加入 `__iter__`,`__getitem__`, `next`等方法
区别
```python
# __getitem__()
class DataTest():
    def __init__(self, num):
        self.num = num
    
    def __getitem__(self, index):
        if (index < self.num):
            return index
        else:
            raise StopIteration

data = DataTest(20)
for i in data:
    print(i) # 0, 1, 2, ... 19, index是一个自增的变量

print(data[0]) # 直接传递index
```
```python
# __iter__, __next__
class Fib:
    def __init__(self):
        self.a = 0
        self.b = 1
    def __iter__(self):
        return self
    
    def __next__(self):
        self.a, self.b = self.b, self.a+self.b
        return self.a

f= Fib()
for i in f:
    if i > 100:
        break
    print(i)
```
2. 函数前面加下划线

加单下划线是受保护的。双下滑线表示私有的。但是可以通过类名来访问 
```python
class Foo:
    def __name():
        return '1'

f = Foo()
f.__name() # 这样会报错，可以通过f_Foo__name()来访问
```

3. 三元表达式
python中没有`>?:`，用if-else来模拟

```python
a = 1
b = a if a ==1 else 2
```
4. 深浅拷贝

```python
copy, deepcopy

a = {1: [1,2, 3]}
b = a.copy()
a[1].append(4)
# a = {1: [1, 2, 3, 4]}, b = {1: [1, 2, 3, 4]}
from copy import deepcopy
c = {1: [1,2, 3]}
d= deepcopy(c)
c[1].append(4)
# c = {1: [1, 2, 3, 4]}, d = {1: [1, 2, 3]}
```
浅拷贝会拷贝引用，深拷贝对所有内容复制

5. 多个装饰器

多个装饰器装饰的顺序是从里到外，调用的顺序是从外到里
```python
def f1(fn):
    print("f1")
    def inner(*arg, **kwargs):
        print("进入f1")
        result= fn(*arg,**kwargs)
        print("进入f1里面")
        return result
    return inner

def f2(fn):
    print("f2")
    def inner(*arg, **kwargs):
        print("进入f2")
        result = fn(*arg, **kwargs)
        print("进入f2里面")
        return result
    return inner
@f1
@f2
def fn():
    print("1")
    return "结束"

fn()
# f2
# f1
# 进入f1
# 进入f2
# 1
# 进入f2里面
# 进入f1里面
```

6. django orm

    only 只取出表中的某几列，defer表示不取出某几列

    selected_related 相同于进行join,解决1对1或者多对1的关系。
    prefetch_related 对于多对多的关系。分别查表，然后用Python 处理他们的关系

7. Django 中间件

    process_request，从下到上，process_response从上到下。
    自定义中间件，继承MiddlewareMixin, 重写process_request, 和process_response
    可以用来记录日志

8. drf常见组件，permission_classes, autuentication_classes, filter ,自定义组件继承自对应的已定义的组件，并添加对应的选项。

例如 自定义serializer,继承自ModelSerializer, 写下要序列化的字段。Meta字段定义model
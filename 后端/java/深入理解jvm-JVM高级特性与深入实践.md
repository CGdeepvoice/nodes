# 深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）- 周志明
窃书者不为偷也 先读盗版看看，下次一定买

## 第一部分 走近java
### 第1章 走近java
JDK（java development kit）: java语言，jvm, java类库
JRE 是支持java程序运行的标准环境， jdk包含jre

讲了几大公司神仙打架，java越来越火
如何自己编译jdk, 下载源码，使用gcc编译
## 第二部分 自动内存管理
### 第2章 Java内存区域与内存溢出异常 

![avator](images/jvm运行时数据区.jpg)

1. 程序计数器

    是一块较小的内存空间，是当前线程所执行的字节码的行号指示器。在运行过程中，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令，使用程序计数器来实现分支、循环、跳转、异常处理和线程恢复等功能。

2. java虚拟机栈

    线程私有的，生命周期和线程相同。用来描述Java方法执行的线程内存模型：每个方法被执行的时候，jvm会创建一个栈帧来存储局部变量表、操作数栈、动态链接和方法出口等信息。每个方法被调用直至执行完毕就是一个栈帧在虚拟机中从入栈到出栈的全过程。

3. 本地方法栈

    与虚拟机栈类似，区别是虚拟机栈用来执行java方法（字节码）方法，本地方法栈为执行本地方法（native,指的是非java方法，可以理解为调用c、c++方法)。

4. java堆
   
   java堆是jvm管理的内存中最大的一块。java堆是所有线程共享的一块内存区域，在虚拟机启动时创建。用来存放对象实例，几乎所有的对象实例都是在这里分配内存。

   java堆是垃圾回收管理的内存区域，有时会叫做GC堆。

5. 方法区

    与堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

6. 运行时常量池

    方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息，还有一项信息是常量池表，用于存放编译期生成的各种字面量和符号引用，这部分内存放在运行时常量池中。（字面量，这个变量的量就是变量，比如 int x = 3, 3就是字面量， 如果是 int x; x不知道是多少，就不是字面量。js中 let person = {"name": "tom"},这样是一个字面量，概括来说就是不用调用构造函数创建的变量，通过声明就可以描述定义自己的就叫字面量）

7. 直接内存

    直接内存不是虚拟机运行时数据区的一部分。在NIO(New Input/Output)类中引入了基于通道channel和缓冲区的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过java堆内的java堆和native堆中来回复制数据。

#### 2.3 HotSpot虚拟机对象
1. 对象的创建，遇到new指令
    1. 在常量池中定位到类的符号引用，检查是否已经加载、解析和初始化过。如果没有就先进行相应的类加载过程。
    2. 类加载之后为新对象分配内存。对象所需要的内存大小在类加载完成后便已经确定，分配过程就是把一块确定大小的内存从java堆中划分出来。这里有两种情况，1. java堆内存时规整的，一边是使用的，一边是空闲的，指针在中间，分配时直接移动指针即可，这种叫指针碰撞。2. java堆内存不规整，使用的和空闲的相互交错存在，这时候需要用一个列表来记录和维护，每次从空闲的内存中分一块够用的给新对象，这种方式是空闲列表。

        关于java堆是否规整却取决于垃圾回收期是否带有空间压缩整理的能力。

        即使使用指针碰撞这种简单的移动指针的分配方式，在多线程的情况下也存在安全问题，可能给对象A分配了内存，指针还没移动，又给B分配了这里。解决线程安全两种方案：1. 对分配内存空间的动作进行同步处理，即使用CAS（乐观锁）加上失败重试实现更新操作的原子性。2. 使用缓存，每个线程在java堆中预先分配一块内存，本地线程分配缓冲，需要内存时先自己分配，不够了再申请分配新的给线程。
    3. 初始化内存空间为零值，如果使用了TLAB，则进行TLAB分配。tlab就是上面讲的本地线程分配缓冲，Thread Local Allocation Buffer。
    4. 开始对对象进行设置。在对象头中设置：对象是哪个类的实例、如何找到类的元数据信息、对象的哈希吗、对象的GC分代年龄等。
    
    OK,完成了1234，jvm中一个对象就产生了。但是在java程序中对象才刚开始创建，所有的字段都还是零值，资源和状态都还没构造好。之后需要执行init方法了。

2. 对象的内存布局
   对象头、实例数据、对齐填充
   1. 对象头

        对象头包含两类信息：用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。但是这些信息与对象自身定义的数据无关。对象头里包含了类型指针，指向它的类型元数据，通过这个指针确定该对象是哪个类的实例。
    
    2. 实例数据

        类中的各个类型的字段内容。

    3. 对齐填充

        这个不是一定存在的，也没有特别含义，占位符的作用。因为HotSpotJVM的自动内存管理系统要求对象起始地址是8字节的整数倍，也就是任何对象的大小都是8字节的整数倍。对象头已经设计好满足条件了，如果实例数据没对齐，就通过对齐填充来补全。

3. 对象的访问定位

    java虚拟机规范中规定了reference类型是指向对象的引用，也就是为了使用对象。 这里reference存储两种方式: 1. 通过保存在句柄中，放入句柄池中，reference保存句柄池地址 2. 直接保存地址到reference


名词解释：
1. 符号引用

    包含在字节码文件的常量池中的符号，主要包括这个类中出现过的各类包、类、接口、字段、方法等元素的全限定名。
    Class文件里的“符号引用”的实态：带有类型（tag） / 结构（符号间引用层次）的字符串。

    [JVM里的符号引用如何存储？ - RednaxelaFX的回答 - 知乎](https://www.zhihu.com/question/30300585/answer/51335493)

2020/09/24
本想一周内肝完这本书，发现不大行，好多东西看不懂，准备刷一遍视频再来读这本书。这里的不太难，但是不好联系在一起。
立个flag:
1. 马上要国庆了，不到一周时间了，这几天晚上刷一套jvm视频入入门。国庆时候抽时间刷完这本书。
2. 这几天上班时间搞一下java容器源码，国庆回来之后看一下spring系列视频并且入门写一个项目，之后可以一边刷spring核心概念原理源码，一边找java开发工作。
# 深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）- 周志明
窃书者不为偷也 先读盗版看看，下次一定买

## 第一部分 走近java
### 第1章 走近java
JDK（java development kit）: java语言，jvm, java类库
JRE 是支持java程序运行的标准环境， jdk包含jre

讲了几大公司神仙打架，java越来越火
如何自己编译jdk, 下载源码，使用gcc编译
## 第二部分 自动内存管理
### 第2章 Java内存区域与内存溢出异常 

![avator](images/jvm运行时数据区.jpg)

1. 程序计数器

    是一块较小的内存空间，是当前线程所执行的字节码的行号指示器。在运行过程中，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令，使用程序计数器来实现分支、循环、跳转、异常处理和线程恢复等功能。

2. java虚拟机栈

    线程私有的，生命周期和线程相同。用来描述Java方法执行的线程内存模型：每个方法被执行的时候，jvm会创建一个栈帧来存储局部变量表、操作数栈、动态链接和方法出口等信息。每个方法被调用直至执行完毕就是一个栈帧在虚拟机中从入栈到出栈的全过程。

3. 本地方法栈

    与虚拟机栈类似，区别是虚拟机栈用来执行java方法（字节码）方法，本地方法栈为执行本地方法（native,指的是非java方法，可以理解为调用c、c++方法)。

4. java堆
   
   java堆是jvm管理的内存中最大的一块。java堆是所有线程共享的一块内存区域，在虚拟机启动时创建。用来存放对象实例，几乎所有的对象实例都是在这里分配内存。

   java堆是垃圾回收管理的内存区域，有时会叫做GC堆。

5. 方法区

    与堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

6. 运行时常量池

    方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息，还有一项信息是常量池表，用于存放编译期生成的各种字面量和符号引用，这部分内存放在运行时常量池中。（字面量，这个变量的量就是变量，比如 int x = 3, 3就是字面量， 如果是 int x; x不知道是多少，就不是字面量。js中 let person = {"name": "tom"},这样是一个字面量，概括来说就是不用调用构造函数创建的变量，通过声明就可以描述定义自己的就叫字面量）

7. 直接内存

    直接内存不是虚拟机运行时数据区的一部分。在NIO(New Input/Output)类中引入了基于通道channel和缓冲区的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过java堆内的java堆和native堆中来回复制数据。

#### 2.3 HotSpot虚拟机对象
1. 对象的创建，遇到new指令
    1. 在常量池中定位到类的符号引用，检查是否已经加载、解析和初始化过。如果没有就先进行相应的类加载过程。
    2. 类加载之后为新对象分配内存。对象所需要的内存大小在类加载完成后便已经确定，分配过程就是把一块确定大小的内存从java堆中划分出来。这里有两种情况，1. java堆内存时规整的，一边是使用的，一边是空闲的，指针在中间，分配时直接移动指针即可，这种叫指针碰撞。2. java堆内存不规整，使用的和空闲的相互交错存在，这时候需要用一个列表来记录和维护，每次从空闲的内存中分一块够用的给新对象，这种方式是空闲列表。

        关于java堆是否规整却取决于垃圾回收期是否带有空间压缩整理的能力。

        即使使用指针碰撞这种简单的移动指针的分配方式，在多线程的情况下也存在安全问题，可能给对象A分配了内存，指针还没移动，又给B分配了这里。解决线程安全两种方案：1. 对分配内存空间的动作进行同步处理，即使用CAS（乐观锁）加上失败重试实现更新操作的原子性。2. 使用缓存，每个线程在java堆中预先分配一块内存，本地线程分配缓冲，需要内存时先自己分配，不够了再申请分配新的给线程。
    3. 初始化内存空间为零值，如果使用了TLAB，则进行TLAB分配。tlab就是上面讲的本地线程分配缓冲，Thread Local Allocation Buffer。
    4. 开始对对象进行设置。在对象头中设置：对象是哪个类的实例、如何找到类的元数据信息、对象的哈希吗、对象的GC分代年龄等。
    
    OK,完成了1234，jvm中一个对象就产生了。但是在java程序中对象才刚开始创建，所有的字段都还是零值，资源和状态都还没构造好。之后需要执行init方法了。

2. 对象的内存布局
   对象头、实例数据、对齐填充
   1. 对象头

        对象头包含两类信息：用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。但是这些信息与对象自身定义的数据无关。对象头里包含了类型指针，指向它的类型元数据，通过这个指针确定该对象是哪个类的实例。
    
    2. 实例数据

        类中的各个类型的字段内容。

    3. 对齐填充

        这个不是一定存在的，也没有特别含义，占位符的作用。因为HotSpotJVM的自动内存管理系统要求对象起始地址是8字节的整数倍，也就是任何对象的大小都是8字节的整数倍。对象头已经设计好满足条件了，如果实例数据没对齐，就通过对齐填充来补全。

3. 对象的访问定位

    java虚拟机规范中规定了reference类型是指向对象的引用，也就是为了使用对象。 这里reference存储两种方式: 1. 通过保存在句柄中，放入句柄池中，reference保存句柄池地址 2. 直接保存地址到reference

![avator](images/通过句柄访问对象.jpg)
![avator](images/通过直接指针访问对象.jpg)



名词解释：
1. 符号引用

    包含在字节码文件的常量池中的符号，主要包括这个类中出现过的各类包、类、接口、字段、方法等元素的全限定名。
    Class文件里的“符号引用”的实态：带有类型（tag） / 结构（符号间引用层次）的字符串。

    [JVM里的符号引用如何存储？ - RednaxelaFX的回答 - 知乎](https://www.zhihu.com/question/30300585/answer/51335493)

2020/09/24
本想一周内肝完这本书，发现不大行，好多东西看不懂，准备刷一遍视频再来读这本书。这里的不太难，但是不好联系在一起。
立个flag:
1. 马上要国庆了，不到一周时间了，这几天晚上刷一套jvm视频入入门。国庆时候抽时间刷完这本书。
2. 这几天上班时间搞一下java容器源码，国庆回来之后看一下spring系列视频并且入门写一个项目，之后可以一边刷spring核心概念原理源码，一边找java开发工作。

2020/09/29
视频看了，大概了解了其中的核心知识点，还是需要看看书细化一下。
2020/10/09
国庆9天乐
继续填坑，增强自律性

### 第3章 垃圾收集器与内存分配策略
需要回收的是堆和方法区
#### 3.2 对象已死？
确认对象那些已经死去，那些还存活着
1. 引用计数算法
   Python 用这个方法，在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加一，当引用失效就减一。计数器为零时就是死去。
   这个方法一般，需要额外的空间去存储，当存在相互引用时，两个计数器都不是零，也就无法回收。

2. 可达性分析算法
   java、C#的内存管理子系统。通过一系列称为“GC Roots"的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路称为引用链，如果某个对象到"GC Roots"间没有任何引用链相连，或者用图论的话来说就是GC Roots到这个对象不可达时，证明这个对象不可能再使用了。

    ![avator](images/可达性分析算法.jpg)

生存还是死亡？

   当可达性分析算法中判定为不可达对象，进行一次标记。随后进行一次筛选，筛选条件是是否有必要执行finalize()方法。（没有覆盖这个方法或者已经条用过了，finalize()每个对象只会调用一次）如果有必要执行finalize(),该对象放在一个名为F-Queue的队列中。随后会开启一个线程去调用他的finalize方法。之后会对F-Queue中的对象进行第二次小规模的标记，如果第二次依旧是不可达，则进行回收。如果在finalize()方法中建立了关联，则会存活下来。

回收方法区
    jvm规范中说可以不进行回收这部分，因为回收困难，回收的内存也不多。
    主要回收废弃的常量和不再使用的类型。
#### 3.3 垃圾收集算法
大致分两种：引用计数式垃圾收集（直接垃圾收集）和追踪式垃圾收集（间接垃圾收集）。java中使用的追踪式垃圾收集.

分代收集理论
理论依据是：
   - 弱分代假说：绝大多数对象都是朝生夕灭。
   - 强分代假说：熬过越多次垃圾收集过程的对象就越难消亡

设计原则： 收集器将java堆划分出不同的区域，将回收对象依据其年龄（对象熬过垃圾收集过程的次数）分配到不同的区域中存储。每次垃圾收集都更关注年龄小的区域，可以用较小的代价回收较大的空间。对于难以消亡的对象，集中存放在一起，以较低的频率去回收它。

1. 标记-清除算法

    最基础的垃圾收集算法，后面的算法都是在这个基础上完善的。分为两部分：标记，清除。标记出需要回收的对象，完成标记后统一回收。

    缺点是 有大量碎片、执行效率不稳定。

    ![avator](images/标记清除.jpg)

2. 标记-复制算法

    半区复制，把内存分为大小相等的两块，每次只用一块，一块内存用完了，就进行垃圾收集，把可用的复制到另一块，别的进行清理。
    优点：简单高效，没有碎片。
    缺点：浪费一半空间
    ![avator](images/标记复制.jpg)

    可以进行优化，不用分成大小相等的两块。可以将新生代分成一块较大的Eden空间（伊甸空间）和两个较小的Survivor空间（幸存空间）。每次分配内存只使用Eden和其中一个Survivor。垃圾收集时，将Eden和Survivor中仍然存货的对象一次性复制到另一块Survivor,清理掉Eden和已用过的那块Survivor空间。Eden和Survivor大小是8：1。内存利用率为90%。（有一块幸存区是空的，等待复制，轮回使用两个幸存区）。如果垃圾收集后存活的对象超过了10%，就需要其他内存区域（老年代）进行分配。


3. 标记-整理算法

    标记-复制算法在存活率较高时复制操作多，效率低。
    因为标记-复制需要额外的空间进行分配担保，不适用与老年代。老年代使用标记-整理算法。标记过程相同，后续不是直接进行清除，而是所有的存活对象向内存空间一端移动，直接清理掉边界外的内存。

    ![avator](images/标记-整理.jpg)


## 第三部分 虚拟机执行子系统
### 第六章 类文件结构
class文件时一组以8个字节为基础单位的二级制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符。
class文件结构使用两种数据类型：无符号数和表。
 - 无符号数：以u1, u2, u4, u8来分别代表1个字节、两个字节、四个字节和八个字节的无符号数，用来描述数字，索引类型，数量值和按照UTF-8编码的字符串值。
 - 由多个无符号数或者其他表作为数据项构成的复合数据类型。

文件结构:

![avator](images/Class文件字节码组织结构.png)

  1. 魔数  Class文件的头4个字节，用来确定这个文件是否能被虚拟机接受。为固定的0xCAFEBABE,咖啡宝贝。
  2. 版本号  紧接着魔数的4个字节， 第五六个字节是此版本号，第七八个字节为主版本号。
  3. 常量池 主次版本号之后是常量池入口。
  4. 常量池计数值 位于常量池开头，也就是版本后后面，偏移地址为 0x00000008, 是从1开始的计数值。例如 0x0016为十进制的22，代表常量池中有21项常量。
  5. 访问标志  常量池结束之后，2个字节代表访问标志。用于识别一些类或者接口层次的访问信息。
  6. 类索引、父类索引，这两个索引都是一个u2类型的数据，接口索引集合是一组u2类型的数据集合。两个索引之后是接口计数器，表示接口索引集合的容量。后面会跟着接口信息数据区。
  7. 字段表集合 包含字段计数器和字段表。描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。
  8. 方法表集合 方法计数器和方法表。 类中的方法
  9. 属性表集合 属性计数器和属性表。在Class文件，字段表，方法表中都可以携带自己的属性集合。

### 第7章 虚拟机类加载机制
代码编译的结果是从本地机器码转变为字节码


![avator](images/类的生命周期.jpg)

1. 加载， 加载阶段完成三件事
   - 通过一个全类名来获取定义此类的二进制字节流
   - 将字节流锁代表的静态存储结构转化为方法区的运行时数据结构
   - 在堆内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类数据访问入口

2. 验证 确保Class文件的字节流中包含的信息符合全部约束要求，保证信息运行后不会危害虚拟机自身的安全。
3. 准备 正式为类中定义的变量（静态变量）分配内存并设置类的变量初始值。分配在方法区中。
4. 解析 java虚拟机将常量池内的符号引用替换为直接引用的过程。
5. 初始化 根据代码去初始化类变量和其他资源

jvm内置了三个重要的ClassLoader
  - BootstrapClassLoader(启动类加载器) 最顶层的加载器，由C++实现，负责加载`%JRE_HOME%/lib`目录下的jar包和类或者被-Xbootclasspath参数指定的路径中的所有类。
  - ExtensionClassLoader(扩展类加载器) 主要负责加载目录`%JRE_HOME/lib/ext`目录中的jar包和类，或者被java.ext.dirs系统变量指定的路径下的jar包。
  - AppClassLoader(应用程序类加载器) 面向用户的加载器，负责加载当前用classpath下的所有jar包和类。


**双亲委派机制**

![avator](images/双亲委派机制.jpg)

每个类都会被它对应的类加载器进行加载。在类加载过程中，系统首先判断当前类是否加载过。加载过就返回，没有加载过就进行类加载。当一个类加载器接收到类加载的请求，首先不会自己去尝试加载，而是委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的类家在请求最终应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（搜索范围内找不到）时，子加载器才会尝试自己去完成加载。

双亲委派机制的代码在java.lang.ClassLoader的loadClass()中。

优点： 双亲委派机制保证了java程序的稳定运行，可以避免类的重复加载，也保证了java核心的API不会被篡改。如果没有双亲委派机制，每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为java.lang.Object类的话，那么程序运行时就会出现多个不同的Object类。

自定义类加载器： 继承java.lang.ClassLoader方法。

**模块化系统**
java9引入了java模块系统。原因：
  - java运行环境膨胀和臃肿。每次jvm启动，都会有30-60M的内存加载，用于加载jvm需要的rt.jar。模块化只需要加载程序运行需要的class.
  - 每个公共类都可以被类路径下的任何其他公共类访问，导致无意中使用了并不想被公开访问的API
  - 模块用来管理package,通过声明某个package暴露，模块的概念，其实就是package外再裹一层，不声明默认就是隐藏。

目标：
   - 减少内存的开销
   - 简化各种类库的维护过程
   - 改进安全性

实现过程：在每个模块的顶级文件目录下创建module-info.java文件，使用exports packagename,来声明暴露包名，用requires modulename来声明需要加载的模块。

### 第8章 虚拟机字节码执行引擎
虚拟机不同于物理机，物理机的执行引擎直接建立在处理器、缓存、指令集和操作系统层面上，虚拟机的执行引擎由软件实现。
1. 运行时栈帧结构。对于执行引擎，只有处于栈顶的栈帧还是当前栈帧，与这个栈帧关联的方法称为当前方法。

![avator](images/栈帧结构.jpg)
    
    栈帧里包含了局部变量表，操作栈，动态链接，返回地址等信息，下面会详细了解下每项的具体执行过程

   1. 局部变量表

        局部变量表保存着方法中变量值的存储空间，用于存放方法的参数和内部定义的局部变量。在编译成Class文件时已经在方法的Code属性max_locals数据项确定了需要分配的局部变量表的最大容量。
        局部变量以变量槽的形式存在，一个变量槽存放一个32位以内的数据类型，如果是64位的long,double可以分成两个32位的存放。**变量槽**可以重用，所以在声明一个变量占用内存较多时但实际已经不再使用时，手动设置为null可以节省内存，因为这里不存在垃圾回收，只有出栈才会释放，所以长期占用无用内存很浪费。但是书上并不推荐这样写，因为不同的jvm实现方式不同，可能没用。
        在模型上来看两个栈帧是完全独立的，但是实际实现过程中，会有让下面一个栈帧的部分局部变量表与上面一个栈帧的局部变量表重叠一部分，这样做1.可以节约空间，2.因为是下面的方法调用上面的方法，传参时可以直接使用，不用再复制了。

    2. 操作数栈

        操作数栈就是一个栈，通过入栈和出栈进行计算，比如有一条加法指令iadd,这条指令运行的时候要求操作数栈中最接近栈顶的两个元素已经存放了两个int值，执行时候把这两个值出栈相加在入栈。

    3. 动态链接

        每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，可以在方法调用的过程中动态链接。
        常量池分为静态常量池和运行时常量池：
        - 静态常量池， class文件中的常量池。包含了字面量和符号引用量。字面量就是java语言层面的使用final声明的字符串等。符号引用量包含：类和接口的全限定名，字段名称和描述符，方法名和描述符。
        - 运行时常量池，在jvm加载类之后，将class文件中的常量池载入到内存的方法区中。比如String x = “hello"; String y = "hello"; x == y; x和y的地址是相同的。这里常用String.intern()方法，查找常量池中是否存在一个equal相等的字符串，如果有就返回常量池中的地址，如果没有就添加到常量池中。

        这里介绍的动态链接，其实就是运行时常量池中的这个过程。

    4. 方法返回地址

        程序退出两种方式，正常返回和异常退出。当退出时也就是出栈，可能执行的步骤：恢复上层方法的局部变量表和操作数栈，返回值入栈上一层的操作数栈，调整程序计数器为上个栈帧的指令前。

2. 方法调用

2020/10/10 TODO : 后面读着有点晦涩，先跳过一部分，等后续有时间再填坑

## 第四部分 程序编译与代码优化
### 第10章 前端编译与优化
java中的编译期可能是指前端编译器，把java文件转变成class文件。可能是即时编译器（JIT），运行期把字节码转变为本地机器码。可能是静态的提前编译器（AOT)把程序编译成目标机器指令集相关的二进制代码。
- 前端编译器 JDK的javac
- 即时编译期 HotSpot的C1, C2编译器
- 提前编译器 JDK的Jaotc
  
第十章指的还是第一种，javac编译过程，javac是用java语言实现的

javac的总体过程大概有4个：
  - 准备过程：初始化插入式注解处理器
  - 解析与填充符号表，词法、语法分析，填充符号表
  - 插入式注解处理器的注解处理过程
  - 分析与字节码生成过程：标注检查、数据流和控制流分析、解语法糖、字节码生成

![avator](../java/images/javac的编译过程.jpg)

这里详细的不了解了，后续可以看 TODO : 编译原理

语法糖：
  1. 泛型
  2. 自动装箱、拆箱和遍历循环（for-each)
  3. 条件编译

### 第五部分 高效并发
#### 第12章 java内存模型与线程
![avator](images/java内存模型.jpg)

所有的变量存在主内存中，每个线程有自己的工作内存，保存了变量的主内存副本，线程中对变量的操作在自己的工作内存中进行，有点像前面的tlab.
这里的工作内存、主内存、线程与java内存中的堆、栈、方法区没什么关系，属于不同层次对内存的划分。

交互操作：
 - lock 锁定，作用在主内存变量，把一个变量标识为一条线程独占的状态
 - unlock 解锁，释放变量
 - read 读取，作用于主内存，从主内存读取到线程的工作内存
 - load 载入，作用于工作内存，把read的内存加载到工作内存中
 - use 使用 把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值得字节码指令时将会执行这个操作
 - assign 赋值，在工作内存中，将执行引擎中接收到的值赋值给工作内存中的变量
 - store 存储，作用于工作内存中的变量，把一个变量的值传递到主内存中，以便随后的write
 - write 写入，作用于主内存的变量，把store操作读取的值写入到主内存的变量

**volatile型变量**
使用volatile的变量有两个特性：
  - 对所有线程可见，这里的可见性是指，当一个线程修改了这个变量的值，volatile保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。
  - 禁止指令重新排序优化，普通变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到争取的结果。

为什么volatile对所有线程都是可见的？
因为不会缓存在寄存器或者其他cpu不可见的地方，每次读取都是直接读取内存，所以都是可见的。对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。

**线程的实现**
Java.lang.Thread里的大部分API都是Native的，是平台实现的，不是java实现的。实现线程的三种方式：1.使用内核线程实现（1：1），使用用户线程实现（1：N），使用用户线程加轻量级进程混合实现（N：M）
1. 内核线程实现，直接由内核完成线程的切换，内核操作调度器对线程进行调度，把线程的任务映射到各个处理器上。程序一般使用轻量级进程LWP,轻量级进程就是通常意义上的线程，轻量级进程与内核线程之间是1：1的。
2. 用户线程实现，建立在用户空间的线程库上，调度是在用户态中完成。所有的线程操作需要用户自己去完成，包括线程创建、销毁、切换和调度。
3. 混合实现，即存在用户线程，也存在轻量级进程。
java中的线程中，主流的虚拟机是使用基于操作系统原生的线程模型来实现

**java线程调度**
分为两种，协同式和抢占式。协同式就是线程的执行时间由线程自己控制，一个结束主动通知系统切换到另一个。如果一个一直不停就会崩溃。抢占式的就是由系统分配执行时间，线程的切换不由线程本身来决定。

TODO ： 这里介绍的线程不大行，后面一章就是讲线程安全和锁了。还是新开一本书来看并发的吧

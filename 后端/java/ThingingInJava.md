# Thinking In Java 读书笔记
## 第1章 对象入门
### 1.1 抽象
**纯粹** 的面向对象程序设计方法：
1. 所有东西都是对象。
2. 程序是对象的组合，彼此通过消息传递进行调用。
3. 每个对象都有自己的存储空间，可以容纳其他对象。
4. 每个对象都有一种类型。即type，对象的类型就是class.
5. 同一类的所有对象都能接收相同的消息。可替代性

### 1.2 对象的接口
接口定义能够对某一特定对象发出请求。

### 1.3 实现方案的隐藏
类的定义中会隐藏一些方法或者字段，对使用者进行隐藏。访问控制 public/private/protected

### 1.4 方案的重复使用（复用）
**组织** 在现有类的基础上组织一个新类。也称为包含关系

### 1.5 继承： 重新使用接口
通过**extends**关键字进行继承，并扩展为需要的对象。
区分基础类和衍生类：
1. 为衍生类添加新函数
2. 改变一个基础类现有函数的行为。改善这个函数。

如果子类没有添加新方法，只是改善了父类，就可以用子类替换父类，属于 **is-a**的关系，也就是等价。
如果子类添加了新方法，就不能纯粹的替换父类，现在父类和子类是一种类似的关系，**is-like-a**

"abstract class" 属于 is-a
"interface" is-like-a

### 1.6 多形对象的互换使用
把一个对象当做基类的对象来对待，称为多形性。实现多形性的方法是动态绑定，向对象发送消息时，被调用的代码直到运行时才能确定。
子类可以当做基类的过程叫做向上转型 upcasting

### 1.7 对象的创建和存在时间
在堆栈上创建对象，编译期可以知道对象存货时间，可以利用垃圾回收器进行回收。这里需要读一下jvm,读完这本就去看jvm

集合
向下转型可以强制类型转换，可能会引起异常
常用的list/map/set

单根结构，所有的类都是继承自**Object**,这里写了和c++的对比，各有优劣，只是选择这种方式。

### 1.8 Exception控制，解决错误
这里应该是吧exception翻译成了违例,看起来有点奇怪，但是翻译确实是`规则之外的事`
throw / try / catch / finally

### 1.9 多线程
可以每个处理器进行一个任务，实现并行计算。
synchronized解决共享资源问题

### 1.10 永久性
程序停止运行，对象继续存在，保留全部信息。目前没有很好的实现，有限永久性，把对象写入文件或者数据库，启动再读。

### 1.11 java和因特网
大部分都还是用java写的后端，别的语言比较少。
### 1.12 分析和设计
有计划的完成工作。


### 小结
第一章写的都是引入概念，写的挺复杂的，但是仔细想想也还好都是常用的概念。
做笔记确实能理清思路！！！ 不然看着多又杂，看完就忘了，get不到重点。
jvm还有个大坑要填

## 第2章 一切都是对象
### 2.1 用句柄操纵对象
handle,
遥控控制电视，没有电视，遥控可以单独存在，但是无法使用 String s;
此时调用s的方法会报错。安全的做法是创建句柄并进行初始化。

### 2.2 所有对象都必须创建
String s = new String("asd");
通过关键字new来创建对象

- 保存在什么地方
  - 寄存器，cpu内部，容量有限而且用户不能直接控制。
  - 堆栈， 驻留在ram（随机访问存储器，其实就是内存，也叫主存，可以直接和cpu进行数据交换）,通过指针进行操作，java数据保存在堆栈里，对象句柄等，但是java对象不在这里
  - 堆， 内存池，也是ram。堆（heap）区别于堆栈(stack)，因为编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要停留多久。比栈更灵活。java对象保存在这里（new)。缺点就是分配空间花费时间长。
  - 静态存储。static,也在内存中。程序运行期间可以随时获取调用。
  - 常数存储。常数一般存储在程序代码内部，因为永远不会改变。可以考虑放入rom，只读存储器。(查了一下，这个也是内存，不过不同于上面的内存条，这个在主板上，用来存放bios的)
  - 非ram存储，指的是流式对象（stream， 用来发送接收）和固定对象（存在磁盘）

特例：主要类型
对于一些常用的类型，不用每次都用new来创建，而是创建一个并非句柄的”自动“变量。变量容纳了具体的值，放在堆栈里，可以高效的存储。（应该是用到的太多了，每次都new浪费时间）
boolean/char/byte/short/int/long/float/double/void
BigInteger/BigDecimal 没有对应的基本类型，但是也可以直接用。

java的数组
默认值是null,保证一定的安全性。

### 2.3 绝对不要清楚对象
1. 作用域
这种做法在java里非法
```java
{
    int x = 12;
    {
        int x = 13; // 非法
    }
}
```
2. 对象的作用域
new创建对象的作用域不同于句柄的作用于，会一直存在，靠垃圾收集器进行删除。
### 2.4 新建数据类型：类
1. 字段和方法
   
    这里讲了用class创建类，用点运算符去获取字段和方法。
    如果字段是主数据类型（int, char,byte, boolean, short, long,float,double)，则会自动创建默认值
### 2.5 方法、自变量和返回值
方法就是函数，但是通常都叫方法，方法是决定了一个对象能接受的消息。
### 2.6 构建Java程序
介绍了java的包命名机制，域名反转
使用预先定义好的类，使用import即可
static关键字，并不存储在对象中，存储在类中，共享数据，可以使用 类名.字段 访问
### 2.7 第一个java程序
介绍应该怎么写和运行一个程序

### 2.8 注释和嵌入文档
/*
*
*/

//

@see 引用其他类
@param 参数名 说明
@return 说明
@exception exception类名 说明

### 2.9 编码样式
首字母大写

### 小结
第二章讲的还是些基础。重点是对象保存在堆里，其他保存在栈里。

## 第3章 控制程序流
这里应该挺多基础都是和别的一样的，只记录不会的点

## 第4章 初始化和清楚
这章讲了初始化和垃圾回收
### 4.1 用构建器自动初始化
构造函数与类名相同
### 4.2 方法过载
重载，方法名相同，但是参数不同，根据传的参数调用不同的方法
如果没有写构造方法，编译器会自动创建一个空的构造方法，如果有就不会创建空的

### 4.3 清除：收尾和垃圾回收

finalize() 在垃圾回收时系统会调用，可以用来观察垃圾回收过程
system.gc() 可以调用垃圾回收
system.runFinalization() 垃圾清理

### 4.4 成员初始化
方法内的变量没有默认值，但是类的成员变量有默认值

### 小结
讲了如何写构造函数，java有垃圾回收，但是垃圾回收具体怎么实现没有写

## 第5张 隐藏实现过程
控制访问权限，翻译的不大对这里

### 5.1 包： 库单元
讲了代码组织，每个类对应一个class文件，将特定包的class文件都置于同一目录下。
### 5.2 java访问指示符
public 接口访问权限
propected 继承访问权限
private 不可访问
friendly 默认 包级访问权限

### 5.3 接口与实现
访问权限控制被称为是具体实现的隐藏，把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作是封装。

### 5.4 类访问
每个编译单元只能有一个Public类。public类的名称必须完全与含有该编译单元的文件匹配。编译单元内完全不带public类也可以，但是不常用

### 小结
java通过package、包命名、import进行命名空间的管理。
对成员进行访问权限控制：
 1. 使用户不要触碰那些不该触碰的部分。
 2. 让类库的设计者可以更改类的内部工作方式，而不影响用户使用

## 第6章 类再生 （复用类）
不同版本的翻译也是各不相同
如何复用一个类？  
 1. 组合
 2. 继承

### 6.1 组合语法
在新类中产生现有类的对象，也就是创建对象作为成员变量使用
### 6.2 继承语法
extends
对于带参数的构造器，必须使用super进行显式的调用基类的构造器
### 6.3 组合和继承结合使用
确保正确的清除: try catch finally
### 6.4 选择组合还是继承
### 6.7 向上转型

子类转型为基类
### 6.8 final 关键字
final数据： 永不改变的编译时常量
final方法： 锁定方法，禁止继承类修改， 提高调用效率
final类：  禁止继承

###  6.9 初始化和类加载
java中类的代码在初次使用时才加载，在访问static域或static方法时也会被加载，初次使用处即static初始化发生之处
累的加载过程（创建子类对象）
1. static字段，先父类后子类
2. 构造函数，先父类后子类
3. 调用方法

### 小结
介绍了继承组合的关系
is-a用继承 has-a用组合

## 第7章 多态
这里还挺重点的

多态通过分离 “做什么”和“怎么做”，从另一角度把接口和实现分离。多态可以改善代码的组织结构和可读性，还可以方便扩展

通俗讲就是 同一个接口，不同实例进行执行，进行的操作是不一样的。

**封装**是通过合并特征和行为来创建新的数据类型，实现隐藏则是用过细节私有化将接口和实现分离，而多态则是消除类型之间的耦合关系。
### 7.1 向上转型
一个对象可以作为自己的类型使用，或者作为它的基础类型的一个对象。因为继承树父类在上面的，所以子类作为父类使用就是向上转型。
### 7.2 深入理解
编译器无法得知到底是基类的哪个导出类

public int d（x){
    x.do() // 这里方法的调用，不能确定x的具体类型是什么，只有到了执行的时候才能知道。
}

1. 方法调用的绑定
   
    将一个方法调用同一个方法主体关联起来的行为成为绑定。这里有前期绑定和后期绑定，前期绑定就是在程序执行前进行绑定，C语言是这种。后期绑定是在程序运行时，根据对象的类型进行绑定，也叫动态绑定。

2. 产生正确的行为
   
   java中的方法都是通过动态绑定实现多态

3. 可扩展性

### 7.3 覆盖与重载
子类可能会覆盖父类的方法
重载： 同一个东西在不同的地方具有不同的含义
覆盖： 随时随地都只有一种含义
### 7.4 抽象类和方法
# Thinking In Java 读书笔记
## 第1章 对象入门
### 1.1 抽象
**纯粹** 的面向对象程序设计方法：
1. 所有东西都是对象。
2. 程序是对象的组合，彼此通过消息传递进行调用。
3. 每个对象都有自己的存储空间，可以容纳其他对象。
4. 每个对象都有一种类型。即type，对象的类型就是class.
5. 同一类的所有对象都能接收相同的消息。可替代性

### 1.2 对象的接口
接口定义能够对某一特定对象发出请求。

### 1.3 实现方案的隐藏
类的定义中会隐藏一些方法或者字段，对使用者进行隐藏。访问控制 public/private/protected

### 1.4 方案的重复使用（复用）
**组织** 在现有类的基础上组织一个新类。也称为包含关系

### 1.5 继承： 重新使用接口
通过**extends**关键字进行继承，并扩展为需要的对象。
区分基础类和衍生类：
1. 为衍生类添加新函数
2. 改变一个基础类现有函数的行为。改善这个函数。

如果子类没有添加新方法，只是改善了父类，就可以用子类替换父类，属于 **is-a**的关系，也就是等价。
如果子类添加了新方法，就不能纯粹的替换父类，现在父类和子类是一种类似的关系，**is-like-a**

"abstract class" 属于 is-a
"interface" is-like-a

### 1.6 多形对象的互换使用
把一个对象当做基类的对象来对待，称为多形性。实现多形性的方法是动态绑定，向对象发送消息时，被调用的代码直到运行时才能确定。
子类可以当做基类的过程叫做向上转型 upcasting

### 1.7 对象的创建和存在时间
在堆栈上创建对象，编译期可以知道对象存货时间，可以利用垃圾回收器进行回收。这里需要读一下jvm,读完这本就去看jvm

集合
向下转型可以强制类型转换，可能会引起异常
常用的list/map/set

单根结构，所有的类都是继承自**Object**,这里写了和c++的对比，各有优劣，只是选择这种方式。

### 1.8 Exception控制，解决错误
这里应该是吧exception翻译成了违例,看起来有点奇怪，但是翻译确实是`规则之外的事`
throw / try / catch / finally

### 1.9 多线程
可以每个处理器进行一个任务，实现并行计算。
synchronized解决共享资源问题

### 1.10 永久性
程序停止运行，对象继续存在，保留全部信息。目前没有很好的实现，有限永久性，把对象写入文件或者数据库，启动再读。

### 1.11 java和因特网
大部分都还是用java写的后端，别的语言比较少。
### 1.12 分析和设计
有计划的完成工作。


### 小结
第一章写的都是引入概念，写的挺复杂的，但是仔细想想也还好都是常用的概念。
做笔记确实能理清思路！！！ 不然看着多又杂，看完就忘了，get不到重点。
jvm还有个大坑要填

## 第2章 一切都是对象
### 2.1 用句柄操纵对象
handle,
遥控控制电视，没有电视，遥控可以单独存在，但是无法使用 String s;
此时调用s的方法会报错。安全的做法是创建句柄并进行初始化。

### 2.2 所有对象都必须创建
String s = new String("asd");
通过关键字new来创建对象

- 保存在什么地方
  - 寄存器，cpu内部，容量有限而且用户不能直接控制。
  - 堆栈， 驻留在ram（随机访问存储器，其实就是内存，也叫主存，可以直接和cpu进行数据交换）,通过指针进行操作，java数据保存在堆栈里，对象句柄等，但是java对象不在这里
  - 堆， 内存池，也是ram。堆（heap）区别于堆栈(stack)，因为编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要停留多久。比栈更灵活。java对象保存在这里（new)。缺点就是分配空间花费时间长。
  - 静态存储。static,也在内存中。程序运行期间可以随时获取调用。
  - 常数存储。常数一般存储在程序代码内部，因为永远不会改变。可以考虑放入rom，只读存储器。(查了一下，这个也是内存，不过不同于上面的内存条，这个在主板上，用来存放bios的)
  - 非ram存储，指的是流式对象（stream， 用来发送接收）和固定对象（存在磁盘）

特例：主要类型
对于一些常用的类型，不用每次都用new来创建，而是创建一个并非句柄的”自动“变量。变量容纳了具体的值，放在堆栈里，可以高效的存储。（应该是用到的太多了，每次都new浪费时间）
boolean/char/byte/short/int/long/float/double/void
BigInteger/BigDecimal 没有对应的基本类型，但是也可以直接用。

java的数组
默认值是null,保证一定的安全性。

### 2.3 绝对不要清除对象
1. 作用域
这种做法在java里非法
```java
{
    int x = 12;
    {
        int x = 13; // 非法
    }
}
```
2. 对象的作用域
new创建对象的作用域不同于句柄的作用于，会一直存在，靠垃圾收集器进行删除。
### 2.4 新建数据类型：类
1. 字段和方法
   
    这里讲了用class创建类，用点运算符去获取字段和方法。
    如果字段是主数据类型（int, char,byte, boolean, short, long,float,double)，则会自动创建默认值
### 2.5 方法、自变量和返回值
方法就是函数，但是通常都叫方法，方法是决定了一个对象能接受的消息。
### 2.6 构建Java程序
介绍了java的包命名机制，域名反转
使用预先定义好的类，使用import即可
static关键字，并不存储在对象中，存储在类中，共享数据，可以使用 类名.字段 访问
### 2.7 第一个java程序
介绍应该怎么写和运行一个程序

### 2.8 注释和嵌入文档
/*
*
*/

//

@see 引用其他类
@param 参数名 说明
@return 说明
@exception exception类名 说明

### 2.9 编码样式
首字母大写

### 小结
第二章讲的还是些基础。重点是对象保存在堆里，其他保存在栈里。

## 第3章 控制程序流
这里应该挺多基础都是和别的一样的，只记录不会的点

## 第4章 初始化和清除
这章讲了初始化和垃圾回收
### 4.1 用构建器自动初始化
构造函数与类名相同
### 4.2 方法过载
重载，方法名相同，但是参数不同，根据传的参数调用不同的方法
如果没有写构造方法，编译器会自动创建一个空的构造方法，如果有就不会创建空的

### 4.3 清除：收尾和垃圾回收

finalize() 在垃圾回收时系统会调用，可以用来观察垃圾回收过程
system.gc() 可以调用垃圾回收
system.runFinalization() 垃圾清理

### 4.4 成员初始化
方法内的变量没有默认值，但是类的成员变量有默认值

### 小结
讲了如何写构造函数，java有垃圾回收，但是垃圾回收具体怎么实现没有写

## 第5章 隐藏实现过程
控制访问权限，翻译的不大对这里

### 5.1 包： 库单元
讲了代码组织，每个类对应一个class文件，将特定包的class文件都置于同一目录下。
### 5.2 java访问指示符
public 接口访问权限
propected 继承访问权限
private 不可访问
friendly 默认 包级访问权限

### 5.3 接口与实现
访问权限控制被称为是具体实现的隐藏，把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作是封装。

### 5.4 类访问
每个编译单元只能有一个Public类。public类的名称必须完全与含有该编译单元的文件匹配。编译单元内完全不带public类也可以，但是不常用

### 小结
java通过package、包命名、import进行命名空间的管理。
对成员进行访问权限控制：
 1. 使用户不要触碰那些不该触碰的部分。
 2. 让类库的设计者可以更改类的内部工作方式，而不影响用户使用

## 第6章 类再生 （复用类）
不同版本的翻译也是各不相同
如何复用一个类？  
 1. 组合
 2. 继承

### 6.1 组合语法
在新类中产生现有类的对象，也就是创建对象作为成员变量使用
### 6.2 继承语法
extends
对于带参数的构造器，必须使用super进行显式的调用基类的构造器
### 6.3 组合和继承结合使用
确保正确的清除: try catch finally
### 6.4 选择组合还是继承
### 6.7 向上转型

子类转型为基类
### 6.8 final 关键字
final数据： 永不改变的编译时常量
final方法： 锁定方法，禁止继承类修改， 提高调用效率
final类：  禁止继承

###  6.9 初始化和类加载
java中类的代码在初次使用时才加载，在访问static域或static方法时也会被加载，初次使用处即static初始化发生之处
累的加载过程（创建子类对象）
1. static字段，先父类后子类
2. 构造函数，先父类后子类
3. 调用方法

### 小结
介绍了继承组合的关系
is-a用继承 has-a用组合

## 第7章 多态
这里还挺重点的

多态通过分离 “做什么”和“怎么做”，从另一角度把接口和实现分离。多态可以改善代码的组织结构和可读性，还可以方便扩展

通俗讲就是 同一个接口，不同实例进行执行，进行的操作是不一样的。

**封装**是通过合并特征和行为来创建新的数据类型，实现隐藏则是用过细节私有化将接口和实现分离，而多态则是消除类型之间的耦合关系。
### 7.1 向上转型
一个对象可以作为自己的类型使用，或者作为它的基础类型的一个对象。因为继承树父类在上面的，所以子类作为父类使用就是向上转型。
### 7.2 深入理解
编译器无法得知到底是基类的哪个导出类

public int d（x){
    x.do() // 这里方法的调用，不能确定x的具体类型是什么，只有到了执行的时候才能知道。
}

1. 方法调用的绑定
   
    将一个方法调用同一个方法主体关联起来的行为成为绑定。这里有前期绑定和后期绑定，前期绑定就是在程序执行前进行绑定，C语言是这种。后期绑定是在程序运行时，根据对象的类型进行绑定，也叫动态绑定。

2. 产生正确的行为
   
   java中的方法都是通过动态绑定实现多态

3. 可扩展性

### 7.3 覆盖与重载
子类可能会覆盖父类的方法
重载： 同一个东西在不同的地方具有不同的含义
覆盖： 随时随地都只有一种含义
### 7.4 抽象类和方法
引出抽象类的概念，包含抽象方法的类就是抽象类，子类继承必须实现所有抽象方法，使用abstract关键字
### 7.5 接口
接口可以看做”纯“ 抽象类
类不能多重继承，即a如果extends了b,就不能再继承c了，但可以实现多个接口
接口的字段默认都是final static的，接口是public, 字段不是接口的一部分，只是保存在接口的static存储区域中

### 7.6 内部类
一个类定义置于另一个类定义中，就是内部类。
内部类编译之后也是单独的class文件，内部类分为普通和静态内部类，如果是静态内部类，就是放在一个类里面的一个类而已。如果是普通内部类，则可以访问外部类的成员变量。

### 7.7 构造器和多态
1. 构造器的调用顺序

    基类的构造器总是在导入类的构造过程中进行调用，并按照继承层次转件向上链接。
    - 调用基类的构造器，反复递归，从根一直到最底层导出类的基类
    - 安声明顺序调用成员的初始化方法
    - 调用导入类构造器的主体

2. 继承与清理

    一般不用手动进行清理，如果确实需要，定义finalize()方法。清理的顺序当然就是和构造顺序相反的，从导入类向上进行清理。

3. 构造器内部的多态方法的行为

    这里讲了一个抽象类构造器调用抽象方法，但是子类对象实例化时候调用的子类的实现方法。

### 小结

什么是多态？多态就是同一个行为，在不同情况下的不同表现形式，比如 Person().eat(), person是抽象类，子类可以是Men,Women, 
```java
Person p = new Men(); 
p.eat(); 
Person p2 = new Women();
p.eat();
```
同一行为就是eat,但是子类有各自的实现，数据类型在编译期都是person,是一样的。在运行期才会创建子类对象，然后调用时候就会调用子类的行为。这种可以用父类声明子类对象的行为就是**向上转型**，在运行期将方法与对象进行关联的过程就是绑定。这个机制具体怎么实现我还不清楚，应该也是在jvm里实现的。

感想：这本写的倒是不错，就是叙述太啰嗦了，一整章引入一个概念，但又不是很深入，可能我还没到一定境界，读不出书里的真髓吧。后面要加紧时间看完这个去看一下jvm了，这些概念知道了，需要搞清楚具体怎么实现的。翻译的感觉也是一般般，毕竟没读原文这样也不错了。

## 第8章 对象的容纳
自带的有数组，标准库里有collection，list\set\map，容器就是存放对象的一个容器。
### 8.1 数组
数量固定、类型已知，就可以使用数组了。数组里保存的也是对象，对象都是new保存在堆里，数组里保存的就是句柄（指针）。
数组就是一个简单的线性序列，访问的速度非常快。缺点是创建时候就要申请了固定大小的内存，在使用过程中已知都会持有。而且像扩容，需要申请新的数组，把旧的在复制进去，太麻烦了

### 8.2 集合
集合大小未知，类型未知，获取内容并强制转换可能会出现错误
### 8.3 枚举器 Iterator
iterator可以遍历一系列对象，并选择哪个序列中的每个对象，同时不让客户知道或关注序列的基础结构。iterator也是一个对象.
他这里讲的不太好，下面扩充一下：

这里有两个接口 iterable 和 iterator, 这里iterator是迭代器
```java
public interface Iterator<E> {
    boolean hasNext();
    E next();
    default void remove(){
        throw new UnsupportedOperationException("remove");
    }
    default void forEachRemaining(Consumer<? super E> action){ // 对剩余的进行迭代，next后的结果
        Objects.requireNonNull(action);
        while (this.hasNext()){
            action.accept(this.next());
        }
    }
}
```
再看一下iterable的定义
```java
public interface Iterable<T>{
    Iterator<T> iterator();
    default void forEach(Consumer<? super T> action){
        Objects.requireNonNull(action);
        Iterator var2 = this.iterator();
        while (var2.hasNext()){
            T t = var2.next();
            action.accept(t);
        }
    }
    default Spliterator<T> spliterator(){
        return Spliterators.spliteratorUnknownSize(this.iterator(), 0); 
    }
}
```
从这里知道了，真正实现迭代的是迭代器Iterator，容器想要实现可迭代就要实现Iterable，而Iterable要求有一个Iterator子类对象，所以容器既要实现Iterable接口，又要实现Iterator接口，并创建返回迭代器子类对象。而且不同的容器实现方式各不相同。

看完来collection家族源码也要提上日程了，而且需要结合设计模式，一个不小的工作量看来

### 8.4 集合的类型
这里讲了Vector,BitSet, Stack,Hashtable 这种具体的用法还是等用到时候看吧，先看下大概

### 8.5 排序
自定义sort即可
### 8.6 通用集合库
### 8.7 新集合
这里讲的是java1.2的集合，这里还是看源码好了，它这里有点旧了
## 第9章 异常控制
三种：编译错误、运行时错误、逻辑错误
Throwable异常的根，重要的子类有Exception、Error,其中exception是可以处理的，error是无法处理的

利用try catch finally 进行控制，或者方法后面加throws说明这里不控制，利用throw new 抛出

自定义异常：
```java
class MyException extends Exception{
    public MyException(){}
    public MyException(String msg){
        super(msg);
    }
}
```

## 第10章 JavaIO系统
这里写的不大好，应该单独一片笔记来记录

## 第11章 运行期类型鉴定
运行期类型鉴定（RTTI），当手上只有一个基础类型的句柄，判断它来判断一个对象的正确类型。
利用反射机制进行查找。
### 11.1 class对象
Class对象是用来创建所有常规对象的。类是程序的一部分，每个类都有一个Class对象，每当编写一个新类，就会有一个Class对象，对应一个同名的.class文件。为了生成这个类对象，运行这个程序的jvm会使用“类加载器”的子系统。
类加载器子系统实际上可以包含一条类加载器链，但是只有一个原生类加载器，他是jvm的一部分。当程序创建第一个对象的静态成员引用时就会加载这个类。这证明构造器也是静态方法，所以使用new创建对象也是当做对类的静态成员的引用。

java程序在开始运行之前并非完全加载的，在用到时才会进行加载。类加载器首先检查这个类的Class对象是否已经加载过。如果没加载就根据类名去找.class文件。一旦加载到内存了，就用他来创建对象。
Class.forName()是获取Class对象引用的一种方式。如果类还有加载，在加载过程中，static子句执行。

也可以使用 Xxx.class进行获取，如int.class  等价于 Integer.TYPE

类型检查  x instanceof Dog,   x.isInstance(Dog)

### 11.2 RTTI 语法
可以通过获取到的Class句柄去获取层级结构，如getInterfaces()获取该类实现的接口，getSuperclass()获取父类。

### 11.3 反射：运行期类信息
通过上面的几种方法有一个缺陷，就是编译期必须知道这个类才能进行获取信息，但如果编译期不知道这个类，比如通过web传输一段字节，并且告诉程序这是一个类。这时候编译期是不认识这个类的，应该用反射来进行分析获取。
java.lang.reflect
通过get()set()方法读取和修改Field对象关联的字段，使用invoke()调用与Method对象关联的方法。
getFields(), getMethods(), getConstructors()来获取字段，方法和构造器。

### 小结
只在必须的时候使用RTTI，使用反射还是比较少的

## 第12章 传递和返回对象
传递的对象就是传递的句柄，句柄就是一种安全指针

克隆： 复写cloneable
## 第13章 创建窗口和程序片
## 第14章 多线程
1. 从线程继承，重写run方法， 调用时用start调用
2. 实现Runnable
3. 使用线程池 Executor，使用submit提交任务，获取future对象
使用synchronized共享资源, 对资源进行加锁，一个在读写资源时其他会阻塞
线程几种状态： 新创建， 就绪， 挂起， 结束
设置守护进程，后台执行， setDaemon()
## 第15章 网络编程
## 第16章 设计范式
就是设计模式
## 第17章 项目

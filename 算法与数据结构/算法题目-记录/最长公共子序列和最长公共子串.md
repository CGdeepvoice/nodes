# 描述
1. 最长公共子串： 两个字符串最长的连续的公共的子串  

    s1 = 'abcdefg' s2 = 'acdeg'  comm_sub = 'cde'
2. 最长公共子序列： 两个字符串最长的非连续但是升序的子串

    s1 = 'abcdefg' s2 = 'acdeg'  comm_sub = 'acdeg'

# 分析
都采用动态规划

1. 对于最长公共子序列：
`dp[i][j]`表示到 s1[i] s2[j]时的最长公共子序列，前面有多少个，大于或等于前面的值

这里的状态转移方程式是 
```python
if s1[i-1] == s2[j-1]:  # 如果当前相等，就在前面子串的结果上加一
    dp[i][j] = dp[i-1][j-1]+1
else:
    dp[i][j] = max(dp[i-1][j], dp[i][j-1]) # 如果不想等，就是前面两种情况最大的
```
他的结果就是`dp[-1][-1]`

2. 对于最长公共子串

`dp[i][j]`表示的是以`s1[i] s2[j]`为结尾的子串，因为是连续的，如果相等，那么就是前面子串加一，如果不相等，就是以此结尾的子串没有公共子串，结果就是0，返回值是`dp[][]中最大的值`

状态转移方程式是：
```python
if s1[i-1] == s2[j-1]:
    dp[i][j] = dp[i-1][j-1] + 1
else:
    dp[i][j] = 0
max_len = max(max_len, dp[i][j])
```
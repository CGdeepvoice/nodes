### 第10章 基本数据结构
#### 栈和队列
**栈是先进后出**, **队列是先进先出**
#### 链表
1. `链表linked list`是一种线性顺序排列。数组的线性顺序是由数组的下标决定的，链表是由各个对象的指针决定的。
2. 链表有多种形式，可以分为单链接和双链接（next, prev），已排序和未排序，循环和非循环（尾部的next指向头部）
   
#### 二叉树
`二叉树Binary tree`只有左右子节点的树结构.

### 第11章 散列表
散列表hash table是实现字典操作的有效数据结构。散列表是普通数组概念的推广，由于普通数组可以直接寻址，能在O（1）时间内访问任意位置。散列表中是对关键字进行计算，得出相应的下表进行寻址。
#### 直接寻址表
直接把value放到数组对应Key的位置上。
![avator](images/直接寻址表.jpg)

#### 散列表
利用散列函数（hash函数），由关键字Key计算出槽的位置，并保存value。
这里可能存在一个问题：散列冲突，两个关键字映射到同一个槽中。
![avator](images/散列表.jpg)

解决方法：**链接法** 和 **开放寻址法**
1. 链接法， 把散列到同一槽中的所有元素放入一个链表中。
   ![avator](images/链接法.jpg)

2. 开放寻址法 ：每个关键字都有自己的探查序列，`<h(k, 0), h(k, 1)...h(k, m-1)>`, 按照序列进行检查，如果槽位是空的没有值就直接保存在对应的槽位上。
   > 简单地讲，也就是说，一间厕所，来了一个顾客就蹲其对应的位置，如果又来一个顾客，把厕所单间门拉开，一看里面有位童鞋正在用劲，那么怎么办？很自然的，拉另一个单间的门，看看有人不，有的话就继续找坑。当然了，一般来说，这个顾客不会按顺序一个一个地拉厕所门，而是会去拉他认为有可能没有被占用的单间的门，这可以通过闻味道，听声音来辨别，这就是寻址查找算法。如果找遍了所有厕所单间，看尽了所有人的光屁股，还是找不到坑，那么这座厕所就该扩容了。当然了，厕所扩容不会就只单单增加一个坑位，而是综合考虑成本和保证不让太多顾客拉到裤子里，会多增加几个坑位，比如增加现有坑位的0.72倍。为什么是0.72呢，这是所长多年经营所得到的经验值，为了让自己的经验发扬光大，需要出去演讲，又不能太俗，总不能说“厕所坑位因子”吧，那就把把0.72叫做“装填因子”或者“扩容因子”吧。目前很多产品使用0.72这个常数。

#### 散列函数
将每个关键字尽可能的散列到M个槽位上

### 二叉搜索树
1. 属性：左子孙节点小于父节点，右子孙节点大于父节点
2. 遍历：对于父节点来看，采用递归来输出
   - 前序遍历 先输出父节点，再输出左子树，最后输出右子树
   - 中序遍历 先输出左子树，再输出父节点，最后输出右子树
   - 后续遍历 先输出左子树，再输出右子树，最后输出父节点
### 第六章 堆排序
#### 堆和堆排序
（二叉）堆是一个数组，被看成一个近似的完全二叉树。
![avator](images/堆.jpg)

1. 最大堆和最小堆： 父节点大于/小于子节点
    -  A[PARENT(i)] >= A[i] 最大堆，用于排序(堆排序)
    -  A[PARENT(i)] <= A[i] 最小堆，用于构造优先队列

2. 堆排序 主要步骤
   1. 构建最大堆 A[0...n]
   2. 把第一个元素与最后一个交换 A[0], A[n]
   3. 构建最大堆 A[0...（n-1)] (平衡)
   
```python
class Heap:
    def __init__(self, array):
        self.array = array
        self.size = len(array)
        self.build()

    @staticmethod
    def get_child(parent):
        # parent 是数组索引值 从0开始算，每次计算都要加1
        return parent * 2 + 1
    

    def heapify(self, parent):
        '''
        堆化： 传入一个父节点，由此向下的进行比较交换--堆化
        每次比较父节点和左右子节点，把最大的和父节点进行交换，如果进行了交换则向下继续执行
        这样做不能保证子孙节点都小于这个父节点，因此要从第向下进行堆化
        '''
        left_child, right_child = self.get_child(parent), self.get_child(parent) + 1

        largest = parent
        if left_child < self.size and self.array[left_child] > self.array[largest]:
            largest = left_child
        if right_child < self.size and self.array[right_child] > self.array[largest]:
            largest = right_child
        
        if largest != parent:
            self.array[parent], self.array[largest] = self.array[largest], self.array[parent]
            self.heapify(largest)
        
    def build(self):
        '''
        # 从底向上的建堆
        # 因为根节点在第一个，顺序向下的，所以array[n/2+1....n]都是叶子节点，不需要进行平衡
        # 从最底下的父节点进行建堆即可
        # 一直到第一个 array[0]
        # '''
        for i in range(len(self.array)//2-1, -1, -1):
            self.heapify(i)

    def sort(self):
        '''
        # 堆排序
        # 1. 构建最大堆
        # 2. 每次将第一个数放到堆得最后，并且堆得长度-1 （每次取出最大的放到后面，顺序就出来了）
        # 3. 取出之后的可能不是最大堆，需要重新平衡一下即可
        '''
        for i in range(len(self.array)-1, 0, -1):
            self.array[0], self.array[i] = self.array[i], self.array[0]
            self.size -= 1
            self.heapify(0)
```
- 复杂度：nlgn

#### 优先队列
1. 堆排序是一个优秀的算法，但在实际应用中，快速排序的性能一般会优于堆排序。尽管如此，堆这一数据结构仍然有很多应用。如：作为高效的优先队列，和堆一样，优先队列也有两种形式: 最大优先队列和最小优先队列。
`优先队列(priority queue)`是一种用来维护由一组元素构成的集合 S 的数据结构，其中的每一个元素都有一个相关的值，称为`关键字(key)`。一个`最大优先队列`支持以下操作:
   - INSERT(S,x): 把元素 x 插入集合 S 中。
   - MAXIMUM(S): 返回其最大键值的元素。
   - EXTRACT-MAX(S): 去掉并返回 S 中的具有最大键值的元素。
   - INCREASE-KEY(S,x,k): 将元素 x 的关键字值增加到 k(k 不小于 x的原来值)

```python
class PriorityQueue(Heap):
    def __init__(self, array):
        super().__init__(array)

    def insert(self, x):
        """
        堆中新增一个值
        先在数组最后加一个负无穷，防止上浮报错
        然后提升末尾位置的优先级，即赋值
        然后堆得长度增加
        """
        self.array.append(-float("inf"))
        self.increase(self.size, x)
        self.size += 1

    def maximum(self):
        """
        返回最大值
        """
        return self.array[0]
    
    def extract_max(self):
        """
        返回并从堆中删除最大值
        """
        max_value = self.array.pop(0)
        self.size -= 1
        self.heapify(0)
        return max_value
    
    def increase(self, index, key):
        """
        提升一个索引位置的值
        """
        if key <= self.array[index]:
            raise ValueError("new key is smailler than current key")
        self.array[index] = key
        while index > 0 and self.array[self.get_parent(index)] < self.array[index]:
            self.array[index], self.array[self.get_parent(index)] = self.array[self.get_parent(index)], self.array[index]
            index = self.get_parent(index)
```
### 第七章 快速排序
快速排序的最坏的时间复杂度是 n^2, 但实际排序应用中最好的选择还是快速排序，因为他的平均性能好，他的期望时间复杂度是 nlgn
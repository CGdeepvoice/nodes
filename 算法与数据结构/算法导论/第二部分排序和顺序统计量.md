### 第六章 堆排序
#### 堆和堆排序
（二叉）堆是一个数组，被看成一个近似的完全二叉树。
![avator](images/堆.jpg)

1. 最大堆和最小堆： 父节点大于/小于子节点
    -  A[PARENT(i)] >= A[i] 最大堆，用于排序(堆排序)
    -  A[PARENT(i)] <= A[i] 最小堆，用于构造优先队列

2. 堆排序 主要步骤
   1. 构建最大堆 A[0...n]
   2. 把第一个元素与最后一个交换 A[0], A[n]
   3. 构建最大堆 A[0...（n-1)] (平衡)
   
```python
def max_heapify(array, root):
    # 传入一个数组和一个根节点索引，以此向下进行建堆、平衡堆
    # 即比较父节点和左右子节点，把最大的与父节点交换，如果交换了继续向下平衡
    # 但是不能保证子孙节点都小于此父节点，要从底向上的进行平衡建堆
    # root 为索引从0开始，所以计算子节点要加1
    left_child, right_child = root*2+1, root*2+2
    largest = root
    if left_child < HEAP_SIZE and array[left_child] > array[largest]:
        largest = left_child
    if right_child < HEAP_SIZE and array[right_child] > array[largest]:
        largest = right_child
    if largest != root:
        array[root], array[largest] = array[largest], array[root]
        max_heapify(array, largest)

def build_max_heap(array):
    # 从底向上的建堆
    # 因为根节点在第一个，顺序向下的，所以array[n/2+1....n]都是叶子节点，不需要进行平衡
    # 从最底下的父节点进行建堆即可
    # 一直到第一个 array[0]
    for i in range(len(array)//2-1, -1, -1):
        max_heapify(array, i)

def heap_sort(array):
    # 堆排序
    # 1. 构建最大堆
    # 2. 每次将第一个数放到堆得最后，并且堆得长度-1 （每次取出最大的放到后面，顺序就出来了）
    # 3. 取出之后的可能不是最大堆，需要重新平衡一下即可
    global HEAP_SIZE 
    HEAP_SIZE = len(array)
    build_max_heap(array)
    for i in range(len(array)-1, 0, -1):
        array[0], array[i] = array[i], array[0]
        HEAP_SIZE -= 1
        max_heapify(array, 0)
```
- 复杂度：nlgn

#### 优先队列
